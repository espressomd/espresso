\chapter{Setting up the system}
\label{chap:setup}

\section{\texttt{part}: Setting up particles}
\label{sec:part}

\tclcommand{part}
{
\var{particle\_number}\\
  \opt{pos \var{x} \var{y} \var{z}}
  \opt{type \var{particle\_type\_number}}
  \opt{q \var{charge}}
  \opt{v \var{x\_value} \var{y\_value} \var{z\_value}}
  \opt{f \var{x\_value} \var{y\_value} \var{z\_value}}
  \opt{quat \var{q1} \var{q2} \var{q3} \var{q4}}
  \opt{omega \var{x\_value} \var{y\_value} \var{z\_value}}
  \opt{torque \var{x\_value} \var{y\_value} \var{z\_value}}
  \opt{\opt{un}fix \var{x} \var{y} \var{z}}
  \opt{ext\_force \var{x\_value} \var{y\_value} \var{z\_value}}
  \opt{bond \var{bond\_type\_number}}
  \opt{exclude \var{exclusion\_partner}}
  \opt{delete}
}

This command modifies particle data, namely position, type (monomer, ion, ...), charge, velocity, force and bonds. Multiple properties can be changed at once. If you add a new particle the position has to be set first because of the spatial decomposition.

\begin{arguments}
\item[\var{particle\_number}]
\item[\opt{pos \var{x} \var{y} \var{z}}] Sets the position of this particle to (x,y,z).
\item[\opt{type \var{particle\_type\_number}}] Restrictions: \var{particle\_type\_type\_number} $\geq 0$.
The \var{particle\_type\_number} is used in the inter command to define the parameters of the non bonded interactions between different kinds of particles.
\item[\opt{q \var{charge}}]
\item[\opt{v \var{x\_value} \var{y\_value} \var{z\_value}}]
\item[\opt{f \var{x\_value} \var{y\_value} \var{z\_value}}]
If flag ROTATION is set in config.h, particle properties such as quat, omega and torque can be used:
\item[\opt{quat \var{q1} \var{q2} \var{q3} \var{q4}}]
\item[\opt{omega \var{x\_value} \var{y\_value} \var{z\_value}}]
\item[\opt{torque \var{x\_value} \var{y\_value} \var{z\_value}}]
\item[\opt{fix \var{x} \var{y} \var{z}}] Fixes the particle in space. By supplying a set of 3 integers as arguments it is possible to fix motion in \var{x}, \var{y}, or \var{z} coordinates independetly. For example \var{fix 0 0 1} will fix motion only in z. Note that \var{fix} without arguments is equivalent to \var{fix 1 1 1} (Needs compiled flag EXTERNAL\_FORCES in config.h).
\item[\opt{ext\_force \var{x\_value} \var{y\_value} \var{z\_value}}] An additional external force is applied to the particle (Needs compiled flag EXTERNAL\_FORCES in config.h).
\item[\opt{unfix}] Release any external influence from the particle (Needs compiled flag EXTERNAL\_FORCES in config.h).
\item[\opt{bond \var{bond\_type\_number} \var{partner}+}] Restrictions: \var{bond\_type\_number} $\geq 0$; \var{partner} must be an existing particle.
The \var{bond\_type\_number} is used for the inter command to define bonded interactions.
\item[\opt{exclude \var{exclusion\_partner}+}] Restrictions: \var{exclusion\_partner} must be an existing particle. 
Between the current particle an the exclusion partner(s), no nonbonded interactions are calculated (Needs compiled flag EXTERNAL\_FORCES in config.h). Note that unlike bonds, exclusions are stored with both partners.
Therefore this command adds the defined exclusions to both partners.
\item[\opt{exclude delete \var{exclusion\_partner}+}] Searches for the given exclusion and deletes it. Again deletes the exclusion with both partners.
\item[bond delete] Will delete all bonds attached to this particle.

\end{arguments}

\begin{tclcode}
part <particle_number> delete
\end{tclcode}
If instead of a property "delete" is given, the particle is deleted and all bonds referencing it.
\begin{tclcode}
part <particle_number> print (id|pos|folded_position|type|q|v|f|fix
|ext_force|bond|connections)*
\end{tclcode}
If instead of a property "print" is given the specified properties are written in a simple list form like.
\begin{tclcode}
40 8.849 1.8172 1.4677 1.0 {}
\end{tclcode}
generated by
\begin{tclcode}
part 40 print id pos q bonds
\end{tclcode}
This routine is primarily meant for effective use in Tcl scripts (see e. g. tcl\_blockfile\_write\_particles).

If no property is given,
\begin{tclcode}
part <particle_number>
\end{tclcode}
returns all properties of the particle, if it exists, in the form
\begin{tclcode}
0 pos 2.1 6.4 3.1 type 0 q -1.0 v 0.0 0.0 0.0 f 0.0 0.0 0.0
 bonds { {0 480} {0 368} ... } 
\end{tclcode}
which may be used as an input to this function later on. The first integer is the particle number. 
\begin{tclcode}
part <particle_number> print connections [<range>]
\end{tclcode}
Returns the connectivity of the particle up to a certain number of bonds specified by $<$range$>$ (defaults to 1). For particle 5 in a linear chain the result up to range = 3 would look like:
\begin{tclcode}
{ { 4 } { 6 } } { { 4 3 } { 6 7 } } { {4 3 2 } { 6 7 8 } } 
\end{tclcode}
The function is useful when you want to create bonded interactions to all other particles a certain particle is connected to. Note that this output can not be used as input to the part command. Check results if you use them in ring structures.

\begin{tclcode}
part deleteall 
\end{tclcode}
deletes all particles currently present in the simulation.

Without any parameters at all,
\begin{tclcode}
part auto_exclusions [<range>]
\end{tclcode}
creates exclusions for all particles pairs connected by not more than $<$range$>$ bonds (range defaults to 2). This is typically used in atomistic simulations, where nearest and next nearest neigbor interactions along the chain have to be omitted since they are included in the bonding potentials. For example, if the system contains particles 0...100, where particle n is bonded to particle n-1 for 1$\leq$n$\leq$100, then part auto\_exclusions will result in the exclusions:
\begin{itemize}
  \item particle 1 does not interact with particles 2 and 3
  \item particle 2 does not interact with particles 1, 3 and 4
  \item particle 3 does not interact with particles 1, 2, 4 and 5
  \item ...
\end{itemize}

\begin{tclcode}
part delete_exclusions
\end{tclcode}
deletes all exclusions currently present in the system.

\begin{tclcode}
part
\end{tclcode}
returns the properties of all stored particles in a tcl-list with the same format as specified above:
\begin{tclcode}
{0 pos 2.1 6.4 3.1 type 0 q -1.0 v 0.0 0.0 0.0 f 0.0 0.0 0.0
 bonds{{0 480}{0 368}...}} 
{1 pos 1.0 2.0 3.0 type 0 q 1.0 v 0.0 0.0 0.0 f 0.0 0.0 0.0
 bonds{{0 340}{0 83}...}} 
{2...{{...}...}}
{3...{{...}...}}
...
\end{tclcode}

\section{\texttt{polymer}: Setting up polymer chains}
\label{sec:polymer}

\tclcommand{polymer}
{\var{num\_polymers} 
  \var{monomers\_per\_chain} 
  \var{bond\_length}\\{}
  \opt{start \var{part\_id}}
  \opt{pos \var{x} \var{y} \var{z}}
  \opt{mode < RW | SAW | PSAW > [\var{shield} [\var{max\_try}]]}
  \opt{charge \var{val\_charged\_monomer}}
  \opt{distance \var{dist\_charged\_monomer}}
  \opt{types \var{type\_neutral\_monomer} [\var{type\_charged\_monomer}]}
  \opt{bond \var{type\_bond}}
  \opt{angle \var{phi} [\var{theta} [\var{x} \var{y} \var{z}]]}
}

This command will create \var{num\_polymers} polymer or
polyelectrolyte chains with \var{monomers\_per\_chain} monomers per
chain. The length of the bond between two adjacent monomers will be
set up to be \var{bond\_length}.

\begin{arguments}
\item[\var{num\_polymers}] Sets the number of polymer chains.
\item[\var{monomers\_per\_chain}] Sets the number of monomers per
  chain.
\item[\var{bond\_length}] Sets the distance between two adjacent
  monomers.
\item[\opt{start \var{part\_id}}] Sets the particle number of the
  start monomer to be used with the \keyword{part} command. This
  defaults to 0.

\item[\opt{pos \var{x} \var{y} \var{z}}] Sets the position of the
  first monomer in the chain to \var{x}, \var{y}, \var{z} (defaults to
  a randomly chosen value)
  
\item[\opt{mode < RW | PSAW | SAW > [\var{shield} [\var{max\_try}]]}]
  Selects the setup mode:
  \begin{description}
  \item[\keyword{RW} (Random walk)] The monomers are
    randomly placed by a random walk with a steps size of
    \var{bond\_length}.
  \item[\keyword{PSAW} (Pruned self-avoiding walk)] The position of a
    monomer is randomly chosen in a distance of \var{bond\_length} to
    the previous monomer. If the position is closer to another
    particle than \var{shield}, the attempt is repeated up to
    \var{try\_max} times. Note, that this is not a real self-avoiding
    random walk, as the particle distribution is not the same. If you
    want a real self-avoiding walk, use the \keyword{SAW} mode.
    However, \keyword{PSAW} is several orders of magnitude faster than
    \keyword{SAW}, especially for long chains.
  \item[\keyword{SAW} (Self-avoiding random walk)] The positions of
    the monomers are chosen as in the plain random walk. However, if
    this results in a chain that has a monomer that is closer to
    another particle than \var{shield}, a new attempt of setting up
    the whole chain is done, up to \var{max\_try} times.
  \end{description}
  The default for the mode is \keyword{RW}, the default for the
  \var{shield} is $1.0$, and the default for \var{max\_try} is
  $30000$, which is usually enough for \keyword{PSAW}. Depending on
  the length of the chain, for the \keyword{SAW} mode, \var{max\_try}
  has to be increased by several orders of magnitude.
\item[\opt{charge \var{val\_charged\_monomer}}] Sets the valency of
  the charged monomers.  If the valency of the charged polymers
  \var{val\_charged\_monomer} is smaller than $10^{-10}$, the charge
  is assumed to be zero, and the types are set to
  \var{type\_charged\_monomer} = \var{type\_neutral\_monomer}. This
  defaults to 0.0.

\item[\opt{distance \var{dist\_charged\_monomer}}] Sets the stride
  between the indices of two charged monomers. This defaults defaults
  to 1, meaning that all monomers in the chain are charged.
  
\item[\opt{types \var{type\_neutral\_monomer}
    \var{type\_charged\_monomer}}] Sets the type numbers of the
  neutral and charged monomer types to be used with the \keyword{part}
  command. If \var{type\_neutral\_monomer} is defined,
  \var{type\_charged\_monomer} defaults to 1. If the option is
  omitted, both monomer types default to 0.
  
\item[\opt{bond \var{type\_bond}}] Sets the type number of the bonded
  interaction to be set between the monomers. This defaults to 0.
  
\item[\opt{angle \var{phi} [\var{theta} [\var{x} \var{y} \var{z}]]}]
  Allows for setting up helices or planar polymers: \var{phi} sets
  the angle $\phi$ and \var{theta} sets the angle $\theta$ between
  adjacent bonds. \var{x}, \var{y} and \var{z} set the position of the
  second monomer of the first chain.
\end{arguments}

\section{\texttt{inter}: Setting up interactions}
\label{sec:inter}

\subsection{Nonbonded interactions}
\label{sec:inter_nb}
%\quickrefheading{Nonbonded interactions}

\tclcommand[LENNARD\_JONES]{inter}{%
  \var{type1 type2} 
  lennard\_jones 
  \var{epsilon sigma cutoff shift offset}
}

Defines a Lennard-Jones interaction between particles of the types
\var{type1} and \var{type2}.

$4\varepsilon((\frac{\sigma}{r-offset})^{12}-(\frac{\sigma}{r-offset})^6+shift)\\$
The potential is cut off if
$r > offset+cutoff$
For system warmup you can cap the Lennard-Jones potential with a maximal force which can be set with:
\begin{tclcode}
 inter ljforcecap <maxforce> 
\end{tclcode}
 For particle distances which would lead to larger forces than \var{maxforce} the Lennard-Jones potential is replaced by \var{$r* maxforce$}
Particles placed exactly on top of each other will be subject to a force of magnitude \var{maxforce} applied in $\pm x$ direction. To return to the uncapped potential you have to set \var{maxforce} to zero using
\begin{tclcode}
inter ljforcecap 0
\end{tclcode}
Note that ljforcecap applies to all given Lennard-Jones interactions regardless of the particle types.

\tclcommand{inter}{%
  \var{type1 type2} 
  soft-sphere
  \var{a n cut offset}
}

Todo: write documentation for soft-sphere

\tclcommand{inter}{%
  \var{type1 type2} 
  lj-cos
  \var{epsilon sigma cutoff offset}
}
the Lennard-Jones+Cosine potential (Soddemann et. al. Eur. Phys. J. E. 6, 409-419 (2001))

for $r < r_{min} = offset * 2^{\frac{1}{6}} * \sigma$ :
\begin{center}
$4\varepsilon((\frac{\sigma}{r-offset})^{12}-(\frac{\sigma}{r-offset})^6)$
\end{center}
for $cutoff > r > r_{min} = offset * 2^{\frac{1}{6}} * \sigma$ :
\begin{center}
$\frac{1}{2}\varepsilon(cos(\alpha(r-offset)^2 + \beta)-1)$
\end{center}
where $\alpha$ and $\beta$ are given by:

$\alpha = \frac{\pi}{(cutoff-offset)^2-(r_{min}-offset)^2}\\$

$\beta = \pi * (1 - \frac{(r_{min}-offset)^2}{(cutoff-offset)^2-(r_{min}-offset)^2})\\$


\tclcommand{inter}{%
  \var{type1 type2} 
  lj-cos2
  \var{epsilon sigma offset $\omega$}
}

for $r < r_{change} = offset * 2^{\frac{1}{6}} * \sigma$ :
\begin{center}
$4 \varepsilon((\frac{\sigma}{r-offset})^{12}-(\frac{\sigma}{r-offset})^6)$
\end{center}
for $cutoff = offset * 2^{\frac{1}{6}} * \sigma + \omega > r > r_{change}$:
\begin{center}
$\varepsilon * cos^2(\frac{\pi * (r - r_{change})}{2 * \omega})$
\end{center}

The potential can be capped in the same way as the Lennard-Jones potential. The forcecap is also set using:

\begin{tclcode}
inter ljforcecap <maxforce>
\end{tclcode}

\tclcommand{inter}{%
  \var{type1 type2} 
  morse
  \var{epsilon alpha rmin cut}
}

Todo: write documentation for morse

\tclcommand{inter}{%
  \var{type1 type2} 
  buckingham
  \var{A B C D cut discontinuity shift}
}

Todo: write documentation for buckingham

\tclcommand[TABULATED]{inter}{%
  \var{type1 type2} 
  tabulated
  \var{filename}
}

An arbitrary tabulated non-bonded pair potential.

To use this potential you must provide a file which contains the tabulated forces and energies as a function of the separation distance.

At present the required file format is simply an ordered list separated by whitespace. The data reader first looks for a $\sharp$ character and begins reading from that point in the file. Anything before the $\sharp$ will be ignored.

The first parameter you should supply in the file is the number of data points in the table. This should be an integer. Take care when choosing an appropriate value for the number of points remembering that a copy of each lookup table is kept on each node and must be referenced very frequently.

The second parameter you should supply is the minimum tabulated separation distance. The third parameter should be the maximum tabulated separation distance This will act as the effective cutoff value for the potential. Between minval and maxval the force and energy are assumed to be tabulated at fixed intervals such that the size of this interval is given by:

$\frac{maxval-minval}{n-1}$

Where $ n $ is the number of data points in the table

The remaining data in the file should consist of n data triples \var{distance} \var{force} \var{energy}. Note that distance is only included for human readability of the file. Its values do not matter but it must be present to satisfy the file read format. In the future a more structured file format will be required for the tabulated input file. The values of force and energy should be given as follows:

force: $-\frac{U'(r)}{r}$

energy: $U(r)$

\tclcommand{inter}{%
  \var{type1 type2} 
  gay-berne
  \var{epsilon sigma cutoff k1 k2 mu nu}
}

the Gay-Berne potential for prolate and oblate particles. The Gay-Berne potential is an anisotropic version of the classic Lennard-Jones potential, with orientational dependence in the range and well-depth functions $\sigma$ and $\epsilon$:


the Gay-Berne potential for prolate and oblate particles. The Gay-Berne potential is an anisotropic version of the classic Lennard-Jones potential, with orientational dependence in the range and well-depth functions $\sigma$ and $\epsilon$:



\[ U(\mathbf{r}_{ij}, \mathbf{\hat{u}}_i, \mathbf{\hat{u}}_j) = 4 \epsilon(\mathbf{\hat{r}}_{ij}, \mathbf{\hat{u}}_i, \mathbf{\hat{u}}_j) \left[ \left(\frac {\sigma_0}{\mathbf{r}_{ij}-\sigma(\mathbf{\hat{r}}_{ij}, \mathbf{\hat{u}}_i, \mathbf{\hat{u}}_j)+\sigma_0}\right)^{12}- \left(\frac {\sigma_0}{\mathbf{r}_{ij}-\sigma(\mathbf{\hat{r}}_{ij}, \mathbf{\hat{u}}_i, \mathbf{\hat{u}}_j)+\sigma_0}\right)^{6} \right] \]

where

\[ \sigma( \mathbf{\hat{r}}_{ij}, \mathbf{\hat{u}}_i, \mathbf{\hat{u}}_j) = \sigma_{0} \left\{ 1 - \frac{1}{2} \chi \left[ \frac{ \left( \mathbf{\hat{r}}_{ij} \cdot \mathbf{\hat{u}}_i + \mathbf{\hat{r}}_{ij} \cdot \mathbf{\hat{u}}_j \right)^{2} } {1 + \chi \left( \mathbf{\hat{u}}_i.\mathbf{\hat{u}}_j \right) } + \frac{ \left( \mathbf{\hat{r}}_{ij} \cdot \mathbf{\hat{u}}_i - \mathbf{\hat{r}}_{ij} \cdot \mathbf{\hat{u}}_j \right)^{2} } {1 - \chi \left( \mathbf{\hat{u}}_i \cdot \mathbf{\hat{u}}_j \right) } \right] \right\}^{-\frac{1}{2}} \]

and

\[ \epsilon(\mathbf{\hat{r}}_{ij}, \mathbf{\hat{u}}_i, \mathbf{\hat{u}}_j) = \epsilon_0 \left( 1- \chi^{2}(\mathbf{\hat{u}}_i \cdot \mathbf{\hat{u}}_j) \right)^{-\frac {\nu}{2}} \left[1-\frac {\chi'}{2} \left( \frac { (\mathbf{\hat{r}}_{ij} \cdot \mathbf{\hat{u}}_i+ \mathbf{\hat{r}}_{ij} \cdot \mathbf{\hat{u}}_j)^{2}} {1+\chi' \, \mathbf{\hat{u}}_i \cdot \mathbf{\hat{u}}_j }+ \frac {(\mathbf{\hat{r}}_{ij} \cdot \mathbf{\hat{u}}_i-\mathbf{\hat{r}}_{ij} \cdot \mathbf{\hat{u}}_j)^{2}} {1-\chi' \, \mathbf{\hat{u}}_i \cdot \mathbf{\hat{u}}_j } \right) \right]^{\mu} \] 

re unit vectors $ \mathbf{\hat{u}}_i $ and $ \mathbf{\hat{u}}_j $ give the orientation of the two particles and vector $ \mathbf{r}_{ij} = r_{ij} \mathbf{\hat{r}}_{ij} $ is the intermolecular vector.

The parameters $ \chi = \frac{k_1^{2} - 1}{k_1^{2} + 1 } $ and $ \chi' = \frac{k_2^{1/\mu} - 1}{k_2^{1/\mu} + 1 } $ are responsible for the degree of anisotropy of the molecular properties. $ k_1 $ is the molecular elongation, and $ k_2 $ is the ratio of the potential well depths for the side-by-side and end-to-end configurations. Exponents $ \mu $ and $ \nu $ are adjastable parameters of the potential. There are several Gay-Berne paremeterizations exist; the original one being $ k_1 = 3 $, $ k_1 = 5 $, $ \mu = 2 $ and $ \nu = 1 $.

\bigskip

\subsection{Bonded interactions}
\label{sec:inter_bonded}

\index{Bonded interactions} \index{Bonded interaction type id} Bonded
interactions possess an \emph{bonded interaction type id}. On the one
hand, this id is used when particles and bonds between particles are
specified in the command \texttt{part} (see section \vref{sec:part}).
On the other hand, the id is used when the interaction is specified.

\tclcommand{inter}{%
  \var{bond\_type\_number} 
  fene
  \var{K\_fene R\_fene}
}

\[ U^{FENE} = -\frac{1}{2} K_{FENE} R_{FENE}^2 \ln \left( 1 - \left( \frac{r}{R_{FENE}} \right)^2 \right) \]

\tclcommand{inter}{%
  \var{bond\_type\_number} 
  harmonic
  \var{K\_harmonic R\_harmonic}
}

\[ U^{Harmonic} = \frac{1}{2} K_{harmonic} \left( r - R_{harmonic} \right)^2 \] 

\tclcommand{inter}{%
  \var{bond\_type\_number} 
  subt\_lj
  \var{K\_subt\_lj R\_subt\_lj}
}

This "bonded" interaction subtracts the Lennard-Jones force/energy of every bonded pair from the total force/energy. The first parameter,
\var{K\_subt\_lj}
is a dummy and is not used. The second parameter,
\var{R\_subt\_lj}
is used as a check. If the any bond length in the system exceeds this value, the program crashes. When not needed, this crashing can be disabled by commenting out a few lines in subt\_lj.h . When using this "bonded" interaction, it is worthwhile to consider capping the Lennard-Jones potential appropriately so that round-off errors can be avoided.


\tclcommand{inter}{%
  \var{bond\_type\_number} 
  angle
  \var{bend [phi0]}
}

<bend> is the bending constant in units of KT. The optional parameter <phi0> = $ \phi_o $ is the equilibirum bond angle in rad ranging from 0 to $ \pi $. If this paramter is not given the default value is $ \phi_o = \pi $ which corresponds to a stretched configuration.

\begin{itemize}
  \item Harmonic bond angle potential: (flag: BOND\_ANGLE\_HARMONIC)
      This potential is also used for example in YASP and good old polyMD.

      \[ U^{bend}_{harmonic} = \frac{bend}{2} (\phi - \phi_0)^2 \]

  \item Cosine bond angle potential: (flag: BOND\_ANGLE\_COSINE)
      The ESPResSo original!

      \[ U^{bend}_{cosine} = \frac{bend}{2} (1 + \cos(\phi - \phi0)) \]

  \item Cosine square bond angle potential: (flag: BOND\_ANGLE\_COSSQUARE)
      A form which is used for example in the GROMOS96 force field.

      \[ U^{bend}_{cossquare} = \frac{bend}{2} (\cos(\phi) - \cos(\phi_0))^2 \] 
\end{itemize}

\tclcommand{inter}{%
  \var{bond\_type\_number} 
  dihedral
  \var{mult bend phase}
}

\[ U^{dihedral} = bend \, (1 + phase \, \, cos(mult \, \phi)) \] 

Here $\phi$ is the dihedral angle defined by the particle quadrupel p1, p2, p3 and p4. \var{mult} is the multiplicity of the potential (number of minimas) and can take integer values from 1 to 6. <phase> is a phase parameter which takes the values $\pm1$ and \var{bend} is the bending constant of the potential. Together with appropriate Lennard-Jones interaction this potential can mimic a large number of atomic torsion potentials. The dihedral angle is the angle between the planes defined by the particle triples p1, p2 and p3 and p2, p3 and p4 as illustrated in the figure to the right. Dihedral bonds have to be stored at particle p2!.


\tclcommand[TABULATED]{inter}{%
  \var{bond\_type\_number} 
  tabulated
  \var{bond filename}
}
tabulated bonded potentials can be any potential for bond length potentials, bond angle potentials and dihedral angle potentials. The tabulated forces and energies have to be provided in a seperate file \var{filename}. The format of this file is identical to the one used for the non-bonded tabulated potentials (see the section about them above). The parameter \var{type} defines the type of the potential:

\begin{itemize}
  \item \var{type} = bond (two body interaction)

Tabulated bond length potential. The force acts in the direction of the connecting vector between the particles. The cutoff is given by the maximal tabulated distance. For distances smaller than the tabulated range it uses a linear extrapolation based on the first two tabulated force values. The C implementations are calc\_tab\_bond\_force and tab\_bond\_energy in tab.h.

  \item \var{type} = angle (three body interaction)

Tabulated bond angle potential (see also the normal implemented bond angle potentials). The force on p\_left and p\_right acts perpendicular to the connecting vector between the particle and p\_mid and in the plane defined by the three particles. The force on the middle particle balances the other two forces. The forces are scaled with the invers length of the connecting vectors. It is assumed that the potential is tabulated for all angles between 0 and $ \pi $. The C implementations are calc\_tab\_angle\_force and tab\_angle\_energy in tab.h.

  \item \var{type} = dihedral (three body interaction)

Tabulated torsional dihedral angle potenetial (see also the normal implemented dihedral potentials).It is assumed that the potential is tabulated for all angles between 0 and $ 2\pi $. This potential is not tested yet! Use on own risk. The C implementations are calc\_tab\_dihedral\_force and tab\_dihedral\_energy in tab.h.

\end{itemize}

\subsection{Coulomb interaction}
\label{sec:inter_electrostatics}

\tclcommand{inter}{%
  \var{bond\_type\_number} 
  coulomb
  \var{bjerrum\_length method parameters}
}

sets the method to calculate the electrostatic interaction.

\begin{tclcode}
inter coulomb 0.0
\end{tclcode}

disables coulomb interactions hence deactivating the electrostatic subsystem.

\begin{tclcode}
inter coulomb
\end{tclcode}

returns the actual parameters of the coulomb interaction as a tcl-list, e. g.

\begin{tclcode}
{coulomb 1.0 p3m 7.75 8 5 0.1138 0.0} {coulomb epsilon 0.1
n_interpol 32768 mesh_off 0.5 0.5 0.5}
\end{tclcode}

which has the correct format to be used as input to 'inter' as well. If

\begin{tclcode}
inter coulomb 0.0
\end{tclcode}

is returned, no electrostatics are active at the moment.

Implemented Methods are:

\subsubsection{P3M}

\tclcommand{inter}{%
  \var{bond\_type\_number} 
  p3m
  \var{r\_cut mesh cao alpha}
}

or

\tclcommand{inter}{%
  \var{bond\_type\_number} 
  p3m tune
  accuracy \var{value}
  [
    r\_cut \var{value}
    mesh \var{value}
    cao \var{value}
  ]
}

or

\tclcommand{inter}{%
  \var{bond\_type\_number} 
  p3m tunev2
  accuracy \var{value}
  [
    r\_cut \var{value}
    mesh \var{value}
    cao \var{value}
  ]
}

This is an implementation of the 1/r Coulomb potential

\[ U^{C-P3M} = \ell_B T \frac{q_1 q_2}{r} \]

with help of the P3M Method described elsewhere.

Make sure you know how to tune p3m parameters before using the automatic tuning feature. Details are described in the documentation of P3M\_tune\_parameters rsp P3M\_adaptive\_tune\_parameters.

The two tuning methods follow different methods for determining the optimal parameter. While the tune version simply tries out different values on a grid in the parameter space, the tunev2 version uses a bisection to determine the optimal parameters. In general, for small systems the tune version is faster, while for large systems tunev2 is faster. The results of tunev2 are always at least as good as the parameters achievable from the tune version, and normally the obtained accuracy is much closer to the desired value.

Note that any previous settings of r\_cut, cao and mesh will be remembered. So if you want to retune your electrostatics, e. g. after a major system change, you should use 

\begin{tclcode}
inter coulomb <bjerrum> p3m tune accuracy <acc> r_cut 0
mesh 0 cao 0
\end{tclcode}
Some additional p3m parameters have preset value
\begin{tclcode}
 epsilon = metallic 
\end{tclcode}
The dielectric constant of the surrounding medium, metallic (i.e.infinity) or some finite positive number.
\begin{tclcode}
 n_interpol = 32768 
\end{tclcode}
Number of interpolation points for the charge assignment function. When this is set to 0, interpolation is turned off.
\begin{tclcode}
 mesh_off = 0.5 0.5 0.5 
\end{tclcode}
Offset of the first mesh point from the lower left corner of the simulation box in units of the mesh constant. As soon as p3m is turned on the additional parameters can be changed with:
\begin{tclcode}
inter coulomb <parameter_name> <value(s)>
\end{tclcode}

Make sure that you know the relevance of the P3M parameters before using P3M !!!

\subsubsection{Debye-Hückel potential}

\begin{tclcode}
 dh <kappa> <r_cut>
\end{tclcode}

\[ U^{C-DH} = \ell_B T \frac{q_1 q_2 exp(-\kappa r)}{r} \]

For

\[ \kappa = 0 \]

this corresponds to the plain coulomb potential.
\subsubsection{MMM2D}
\begin{tclcode}
 mmm2d <maximal_pairwise_error> [<fixed_far_cutoff>]
\end{tclcode}
MMM2D coulomb method for systems with periodicity 1 1 0. Needs the layered cell system. The performance of the method depends on the number of slices of the cell system, which has to be tuned manually. It is automatically ensured that the maximal pairwise error is smaller than the given bound. The far cutoff setting should only be used for testing reasons, otherwise you are more safe with the automatical tuning. If you even don't know what it is, do not even think of touching the far cutoff. For details, see The MMM family of algorithms.

Make sure that you read the papers on MMM2D before using it !!!

\subsubsection{MMM1D}
\begin{tclcode}
 mmm1d <switch_radius> [<bessel_cutoff>] <maximal_pairwise_error>
\end{tclcode}
or
\begin{tclcode}
 mmm1d tune <maximal_pairwise_error>
\end{tclcode}
MMM1D coulomb method for systems with periodicity 0 0 1. Needs the nsquared cell system. The first form sets parameters manually. The switch radius determines at which xy-distance the force calculation switches from the near to the far formula. If the Bessel cutoff is not explicitly given, it is determined from the maximal pairwise error, otherwise this error only counts for the near formula. The second, tuning form just takes the maximal pairwise error and tries out a lot of switching radii to find out the fastest one. If this takes too long, you can change the value of the setmd variable "timings" which controls the number of test force calculations. For details, see The MMM family of algorithms.

Make sure that you read the papers on MMM2D before using MMM1D (there are no papers on MMM1D yet, but it is pretty much the same) !!!
\subsubsection{Maggs' method}
\begin{tclcode}
 maggs <f_mass> <mesh> <field_friction>
\end{tclcode}
or
\begin{tclcode}
 maggs <f_mass> <mesh> <field_friction> yukawa <kappa> <r_cut>
\end{tclcode}
This is an implementation of the instantaneous 1/r Coulomb interaction

\[ U = \ell_B T \frac{q_1 q_2}{r} \]

as the potential of mean force between charges which are dynamically coupled to a local electromagnetic field.

\var{f\_mass} is the mass of the field degree of freedom and equals to the square root of the inverted speed of light.

\var{mesh} is the number of mesh points for the interpolation of the electromagnetic field

\var{field\_friction} value of the friction coefficient for the transversal field degrees of freedom (reserved for future developments)

Unphysical self--energies, arised as a result of the lattice interpolation of charges, are corrected by a subtraction scheme based either on the exact lattice Green's function or the combination of the direct subtraction scheme plus the Yukawa subtraction scheme (second method).

For the case of Yukawa screened simulation (second method) one has to enter screening parameter \var{kappa} and the cut-off of the Yukawa potential \var{r\_cut}

\subsubsection{ELC}
\begin{tclcode}
 inter coulomb elc <maximal_pairwise_error> <gap_size> [<far_cutoff>]
\end{tclcode}
This is a special procedure that converts a 3d method, i. e. P3M at the moment, to a 2d method, in computational order N. This is definitely faster than MMM2D for larger numbers of particles (>400 at reasonable accuracy requirements). The maximal pairwise error is the LUB error of the force between any two charges without prefactors (see the papers). The gap size gives the height of the empty region between the system box and the neighboring artificial images (again, see the paper). Espresso does not make sure that the gap is actually empty, this is the users responsibility. The method will compute fine of the condition is not fulfilled, however, the error bound will not be reached. Therefore you should really make sure that the gap region is empty (e. g. by constraints). The far cutoff finally is only intended for testing and allows to directly set the cutoff. In this case, the maximal pairwise error is ignored. The periodicity has to be set to 1 1 1 still, and the 3d method has to be set to epsilon metallic, i.e. metallic boundary conditions. For details, see The MMM family of algorithms.

Make sure that you read the papers on ELC before using it !!!

\subsection{Other interaction types}
\label{sec:inter_other}

\begin{tclcode}
 inter <particle_type_number1> <particle_type_number1>
 comfixed <comfixed_flag>
\end{tclcode}
This interaction type applies a constraint on particles of type \var{particle\_type\_number1} such that during the integration the center of mass of these particles is fixed. This is accomplished as follows: The sum of all the forces acting on particles of type \var{particle\_type\_number1} are calculated. These include all the forces due to other interaction types and also the thermostat. Next a force equal in magnitude, but in the oppositte direction is applied on the particles. This force is divided equally on all the particles of type \var{particle\_type\_number1}, since currently there is no mass concept in Espresso. Note that the syntax of the declaration of comfixed interaction requires the same particle type to be input twice. If different particle types are given in the input, the program exits with an error message. The \var{comfixed\_flag} can be set to 1 (which turns on the interaction) or 0 (to turn off the interaction).
\begin{tclcode}
 inter <particle_type_number1> <particle_type_number2> comforce
 <comforce_flag> <comforce_dir> <comforce_force> <comforce_fratio>
\end{tclcode}
The comforce interaction type enables one to pull away particle groups of two different types. It is mainly designed for pulling experiments on budles. Within a bundle of molecules of type number 1 (t1) lets mark one molecule as of type 2 (t2). Using comforce one can apply a force such that t2 can be pulled away from the bundle. The \var{comforce\_flag} is set to 1 to turn on the interaction, and to 0 otherwise. The pulling can be done in two different directions. Either parallel to the major axis of the bundle ( \var{comforce\_dir} = 0) or perpendicular to the major axis of the bundle (\var{comforce\_dir} = 1). \var{comforce\_force} is used to set the magnitude of the force. \var{comforce\_fratio} is used to set the ratio of the force applied on particles of t1 vs t2. This is useful if one has to keep the total applied force on the bundle and on the target molecule the same. A force of magnitude \var{comforce\_force} is applied on t2 particles, and a force of magnitude (\var{comforce\_force} * \var{comforce\_fratio}) is applied on t1 particles.

\subsection{Getting the currently defined interactions}

%\quickrefheading{Getting interactions}
\tclcommand{inter}{ }
returns a list of all bonded and non-bonded interactions as a Tcl-list, in the same formats as above, e. g.

\begin{tclcode}
 {0 0 lennard-jones 1.0 2.0 1.1225 0.0 0.0} {0 FENE 7.0 2.0} {1 angle 1.0}
\end{tclcode}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "ug"
%%% End: 
