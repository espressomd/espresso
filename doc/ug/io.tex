% Copyright (C) 2010,2011,2012,2013,2014,2015,2016 The ESPResSo project
% Copyright (C) 2002,2003,2004,2005,2006,2007,2008,2009,2010 
%  Max-Planck-Institute for Polymer Research, Theory Group
%  
% This file is part of ESPResSo.
%   
% ESPResSo is free software: you can redistribute it and/or modify it
% under the terms of the GNU General Public License as published by the
% Free Software Foundation, either version 3 of the License, or (at your
% option) any later version.
%  
% ESPResSo is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.
%  
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
\chapter{Input / Output}
\label{cha:io}

\section{No generic checkpointing!}
\label{sec:checkpointing}

One of the most asked-for feature that seems to be missing in \es is
\emph{checkpointing}, \ie a simple way to tell \es to store and
restore the current state of the simulation, and to be able to write
this state to or read it from a file. This would be most useful to be
able to restart a simulation from a specific point in time.

Unfortunately, it is impossible to provide a simple command (\eg
\texttt{checkpoint}), out of two reasons.  The main reason is that \es
has no way to determine what information constitutes the actual state
of the simulation.  On the one hand, \es scripts sometimes use
Tcl-variables that contain essential information about a simulation,
\eg the stored values of an observable that was computed in previous
time steps, counters, etc.  These would have to be contained in a
checkpoint.  However, not all Tcl-variables are of interest. For
example, Tcl has a number of automatically set variables that contain
information about the hostname, the machine type, etc. These variables
should most probably \emph{not} be included the simulation state.  \es
has no way to distinguish between these variables.  On the other hand,
the \es core has a number of internal variables, \eg the particle
coordinates.  While most of these are probably good candidates for
being included into a checkpoint, this is not necessarily so.  For
example, when you have particles in your system that have fixed
coordinates, should these be stored in a checkpoint, or not?  If the
system contains mostly fixed particles and only very few moving
particles, this would increase the memory size of a checkpoint
needlessly. And what about the interactions in the system, or the
bonds? Should these be stored in a checkpoint, or are they generated
by the script?

Another problem with a generic checkpoint would be the control flow of
the script. In principle, the checkpoint would have to store where in
the script the checkpointing function was called to be able to return
there.  All this is even further complicated by the fact that \es is
running in parallel.

Instead, in \es, the user has to specify what information needs to be
saved to a file to be able to restore the simulation state.  The
\texttt{blockfile} and \texttt{writemd} commands help you to do that.
\texttt{blockfile} writes text files.  When floating point numbers are
stored in such files (\eg the particle positions), there is only a
limited precision.  Therefore, it is not possible to bitwise reproduce
a simulation state using this function. When you need bitwise
reproducibility, you will have to use the command \lit{writemd}, which
stores positions, forces and velocities in binary format.  Note that
there is no command to write other MD parameters like time step or
interactions in binary format. You should restore these using exactly
the same Tcl command that you used to create them.

Finally, there is one more complication: random forces are computed
in the order the particles are stored in memory. This order usually
differs after reading a blockfile back, since the particles are
stored in consecutive identity order. In memory, they are usually
not in a specific order. Therefore, you need to use \texttt{sort_particles}
after writing a blockfile that you want to use for checkpointing, so
that the particles are resorted to the same consecutive order. Note
that this does not change physics, just the order the random numbers
are applied.

When using an LB fluid, you need to also write out the fluid nodes,
see the \texttt{lbfluid} command for further details.

\section{\texttt{blockfile}: Using the structured file format}
\label{sec:structured-file-format}
\newescommand{blockfile}

\es uses a standardized ASCII block format to write structured files
for analysis or storage. Basically the file consists of blocks in
curled braces, which have a single word title and some data. The data
itself may consist again of such blocks. An example is:
\begin{tclcode}
{file {Demonstration of the block format}
{variable epsilon {_dval_ 1} } 
{variable p3m_mesh_offset {_dval_ 5.0000000000e-01
   5.0000000000e-01 5.0000000000e-01 } } 
{variable node_grid {_ival_ 2 2 2 } } 
{end} 
\end{tclcode}

\index{whitespace}
Whitespace will be ignored within the format (space, tab and return).

The keyword variable should be used to indicate that a variable
definition follows in the form \var{name} \var{data}. \var{data}
itself is a block with title \lit{_ival_} or \lit{_dval_} denoting
integer resp. double values, which then follow in a whitespace
separated list.  

Such blocks can be read in and written either from \es-scripts (see in
the following subsections), or from your own C-code using the
C-Interface (see section \ref{ssec:blockfilec}).

\subsection{Writing \es's global variables}
\index{global variables}

\begin{essyntax}
  \variant{1} blockfile \var{channel} 
  write variable \{\var{varname1} \var{varname2} \dots \}
  \variant{2} blockfile \var{channel} write variable all
\end{essyntax}

Variant \variant{1} writes the global variables \var{varname1}
\var{varname2} \dots (which are known to the \lit{setmd} command (see
section \vref{tcl:setmd}) to \var{channel}. Variant \variant{2} will
write all known global variables.

Note, that when the block is read, all variables with names listed in
the Tcl variable \lit{blockfile_variable_blacklist} are ignored.

\subsection{Writing Tcl variables}
\index{Tcl global variables}

\begin{essyntax}
  \variant{1} blockfile \var{channel} write tclvariable \{
  \var{varname1} \var{varname2} \dots \}
  \variant{2} blockfile \var{channel} write tclvariable all
  \variant{3} blockfile \var{channel} write tclvariable reallyall
\end{essyntax}

These commands will write Tcl global variables to \var{channel}.
Global variables are those declared in the top scope of the Tcl
script, or those that were explicitly declared global.  When reading
the block, all variables with names listed in the Tcl variable
\lit{blockfile_tclvariable_blacklist} are ignored.

Variant \variant{1} writes the Tcl global variables \var{varname1},
\var{varname2}, \dots to \var{channel}. Variant \variant{2} will write
all Tcl variables to the file, with the exception of the internally
predefined globals from Tcl (\lit{tcl_version}, \lit{argv},
\lit{argv0}, \lit{argc}, \lit{tcl_interactive}, \lit{auto_oldpath},
\lit{errorCode}, \lit{auto_path}, \lit{errorInfo}, \lit{auto_index},
\lit{env}, \lit{tcl_pkgPath}, \lit{tcl_patchLevel}, \lit{tcl_libPath},
\lit{tcl_library} and \lit{tcl_platform}). Variant \variant{3} will
even write those.

\subsection{Writing particles, bonds and interactions}
\begin{essyntax}
  \variant{1} blockfile \var{channel} write particles 
  \var{what} \alt{\var{range} \asep all}
  \variant{2} blockfile \var{channel} write bonds \var{range}
  \variant{3} blockfile \var{channel} write interactions
\end{essyntax}

Variant \variant{1} writes
particle information in a standardized format to \var{channel}.
\var{what} can be any list of parameters that can be specified in
\codebox{part \var{part_id} print}, except for \lit{bonds}.  Note that
\lit{id} and \lit{pos} will automatically be added if missing.
\var{range} is a Tcl list of ranges which particles to write. A range
is defined as \textit{start}-\textit{stop}, where \textit{start} and
\textit{stop} are particle identities. \textit{stop} can also be the
string ``end'', denoting the highest used particle identity. Thus
\texttt{"{} 0-5 10-end"{}} are all particles with the exception of
particles 6-9.  The keyword \keyword{all} denotes all known particles,
\ie{} is eqivalent to \texttt{"0-end"{}}).

Variant \variant{2} writes the bond information in a standardized
format to \var{channel}. The involved particles and bond types must
exist and be valid.

Variant \variant{3} writes the interactions in a standardized format
to \var{channel}.

\subsection{Writing the random number generator states}
\index{random number generators}
\index{random seed}
\begin{essyntax}
  \variant{1} blockfile \var{channel} write random
  \variant{3} blockfile \var{channel} write seed
\end{essyntax}

Variant \variant{1} write the full information on the
current states of the random number generators (see
sections \vref{ssec:trandom}) on any node to
\var{channel}.  Using this information, it is possible to recover the
exact states of the generators.

Variant \variant{3} write only the seed(s) which were
used to initialize the random number generators. Note that this
information is not sufficient to restore the full state of a random
number generator, because the internal state might contain more
information.

\subsection{Writing all stored configurations}
\label{sec:blockfile:configs}
\index{stored configurations}
\begin{essyntax}
  blockfile \var{channel} write configs
\end{essyntax}

This command writes all configurations currently stored for off-line
analysis (see section \vref{sec:stored-configs}) to \var{channel}.

\subsection{Writing arbitrary blocks}
\index{blocks}

\begin{essyntax}
  \variant{1} blockfile \var{channel} write start \var{tag}
  \variant{2} blockfile \var{channel} write end
  \variant{3} blockfile \var{channel} write \var{tag} \opt{\var{arg}}\dots
\end{essyntax}

\var{channel} has to be a Tcl channel. Variant \variant{1} starts a
block and gives it the title \var{tag}, variant \variant{2} ends the
block. Between two calls to the command, arbitrary data can be written
to the channel.  When variant \variant{3} is used, the function
\lit{blockfile_write_}\var{tag} is called with all of the commands
arguments. This function should then write the data.

\minisec{Example}

\begin{tclcode}
set file [open "data.dat" w]
blockfile $file write start "mydata"
puts $file "{This is my data!}"
blockfile $file write end
\end{tclcode}
%$
will write 
\begin{tclcode}
{mydata {This is my data!}}
\end{tclcode}
to the file \lit{data.dat}.

\subsection{Reading blocks}

\begin{essyntax}
  \variant{1} blockfile \var{channel} read start 
  \variant{2} blockfile \var{channel} read toend 
  \variant{3} blockfile \var{channel} read auto 
  \variant{4} blockfile \var{channel} read \alt{particles \asep
    interactions \asep bonds \asep variable \asep seed \asep random
    \asep bitrandom \asep configs}
\end{essyntax}

Variants \variant{1} and \variant{2} are the low-level block-reading
commands. Variant \variant{1} reads the start part of a block and
returns the block title, while variant \variant{2} reads the block
data and returns it.

Variants \variant{3} and \variant{4} read whole blocks.
Variant \variant{3} reads in one block and does the following:
\begin{enumerate}
\item if a procedure \keyword{blockfile_read_auto_\var{tag}} exists,
  this procedure takes over (\var{tag} is the first expression in the
  block). For most block types, at least all mentioned above, \ie
  \keyword{particles}, \keyword{interactions}, \keyword{bonds},
  \keyword{seed}, \keyword{random}, \keyword{bitrandom},
  \keyword{configs}, and \keyword{variable}, the corresponding
  procedure will overwrite the current information with the
  information from the block.
\item if the procedure does not exist, it returns 
  \begin{code}
    \{ \var{usertag} \var{rest\_of\_block} \}
  \end{code}
\item if the file is at the end, it returns \lit{eof}
\end{enumerate}

Variant \variant{4} checks for a block with tag \var{block} and then
again executes the corresponding \lit{blockfile_read_auto_\var{tag}},
if it exists.

In the contrary that means that for a new blocktype you will normally
implement two procedures:
\begin{essyntaxbox}
  blockfile_write_\var{tag} \var{channel} \var{write} \var{tag} \var{arg}\dots
\end{essyntaxbox}
which writes the block including the header and enclosing braces and
\begin{essyntaxbox}
  blockfile_read_auto_\var{tag} \var{channel} \var{read} \var{auto}
\end{essyntaxbox}
which reads the block data and the closing brace. The parameters
\var{write}, \var{read}, \var{tag} and \var{auto} are regular
parameters which will always have the specified value. They occur just
for technical reasons.

In a nutshell: The blockfile command is provided for saving and
restoring the current state of \es, \eg for creating and using
checkpoints. Hence you can transfer all accessible information from
files to \es and vice versa.

\begin{tclcode}
set out [open "|gzip -c - > checkpoint.block.gz" "w"]
blockfile $out write variable all
blockfile $out write interactions
blockfile $out write random
blockfile $out write bitrandom
blockfile $out write particles "id pos type q v f" all
blockfile $out write bonds all
blockfile $out write configs
close $out 
\end{tclcode}

This example writes all global variables, all interactions, the full
current state of the random number generator, all information (\ie id,
position, type-number, charge, velocity, forces, bonds) of all
particles, and all stored particle configurations to the file
\lit{checkpoint.block.gz} which is compressed on-the-fly.  If you want
to be able to read in the information using \es, note that
interactions must be stored before particles before bonding
information, as for the bonds to be set all particles and all
interactions must already be known to \es.

\begin{tclcode}
set in [open "|gzip -cd checkpoint.block.gz" "r"]
while { [blockfile $in read auto] != "eof" } {}
close $in 
\end{tclcode}
This is basically all you need to restore the information in the
blockfile, overwriting the current settings in \es.

\section{Writing and reading binary files}
\index{binary I/O}

Binary files are written using the command
\begin{essyntax}
  writemd \var{channel} \opt{posx|posy|posz|vx|vy|vz|fx|fy|fz}\dots
\end{essyntax}
This will write out particle data to the Tcl channel \var{channel} for
all particles in binary format. Apart from the mandatory particle id,
only limited information can be stored. The coordinates (\keyword{posx},
\keyword{posy} and \keyword{posz}), velocities (\keyword{vx}, \keyword{vy} and
\keyword{vz}) and forces (\keyword{fx}, \keyword{fy} and \keyword{fz}). Other
information should be stored in a blockfile or reconstructed
differently. Note that since both \texttt{blockfile} and
\texttt{writemd} are using a Tcl channel, it is actually possible to
mix them, so that you can write a single checkpoint file. However, the
\texttt{blockfile read auto} mechanism cannot handle the binary
section, thus you need to read this section manually. Reading of
binary particle data happens through
\begin{essyntax}
  readmd \var{channel}
\end{essyntax}
For the exact format of the written binary sequence, see
\texttt{src/tcl/binary_file_tcl.cpp}.


\section{MPI-IO}
\index{mpiio}

When using \es with MPI, blockfiles and writemd have the disadvantage,
that the master node does \textit{all} the output. This is done by
sequentially communicating all particle data to the master node. MPI-IO
offers the possibility to write out particle data in parallel using
binary IO. To output variables and other non-array inforamtion, use
normal blockfiles (section~\ref{sec:structured-file-format}).

To dump data using MPI-IO, use the following syntax:
\begin{essyntax}
  mpiio \var{filename} \opt{read|write} \opt{pos|v|bond|type}
\end{essyntax}
This command writes data to several files using \var{filename} as
filename prefix. Beware, that \var{filename} must not be a Tcl channel
but a string which must not contain colons (MPI fails on these). The
data can be positions (\keyword{pos}), velocities (\keyword{v}),
particle types (\keyword{type}) and particle bonds (\keyword{bond}). The
particle ids are always dumped. For safety reasons, MPI-IO will not
overwrite existing files, so if the command fails and prints
\texttt{MPI_ERR_IO} make sure the files are non-existent.

The files produced by this command will be (assumed \var{filename} is
``1''):
\begin{description}[align=right,labelwidth=2cm]
  \item [1.head] Internal information (Dumped fields, bond partner num); always produced
  \item [1.pref] Internal information (Exscan results of nlocalparts);
    always produced
  \item [1.ids] Particle ids; always produced
  \item [1.type] Particle types; optional
  \item [1.pos] Particle positions; optional
  \item [1.vel] Particle velocities; optional
  \item [1.bond] Bond information; optional
  \item [1.boff] Internal bond prefix information; optional, necessary
    to read 1.bond
\end{description}

Currently, these files have to be read by exactly the same number of MPI
processes that was used to dump them, otherwise an error is
signalled. Also, the same type of machine (endianess, byte order) has to
be used. Otherwise only garbage will be read. The read command replaces
the particles, i.e. all previous existent particles will be
\textit{deleted}.

There is a python script (\texttt{tools/mpiio2blockfile.py}) which
converts MPI-IO snapshots to regular \es blockfiles.


\section{Writing VTF files}
\label{sec:vtf}
%\quickrefheading{Handling of VTF files}
\index{vtf|mainindex}
\index{vcf|mainindex}
\index{vsf|mainindex}

The formats VTF (\textbf{V}TF \textbf{T}rajectory \textbf{F}ormat),
VSF (\textbf{V}TF \textbf{S}tructure \textbf{F}ormat) and VCF
(\textbf{V}TF \textbf{C}oordinate \textbf{F}ormat) are formats for the
visualization software
VMD\cite{humphrey96a}\footnote{\url{http://www.ks.uiuc.edu/Research/vmd/}}. They
are intended to be human-readable and easy to produce automatically
and modify.

The format distinguishes between \emph{structure blocks} that contain
the topological information of the system (\ie the system size,
particle names, types, radii and bonding information, amongst others),
while \emph{coordinate blocks} (a.k.a. as \emph{timestep blocks})
contain the coordinates for the particles at a single timestep.  For a
visualization with VMD, one structure block and at least one
coordinate block is required.

Files in the VSF format contain a single structure block, files in the
VCF format contain at least one coordinate block, while files in the
VTF format contain a single structure block first and an arbitrary
number of coordinate blocks afterwards, thus allowing to store all
information for a whole simulation in a single file. For more details
on the format, refer to the homepage of the
format\footnote{\url{https://github.com/olenz/vtfplugin/wiki/VTF-format}}.

Creating files in these formats from within \es is supported by the
commands \lit{writevsf} and \lit{writevcf}, that write a structure
respectively a coordinate block to the given Tcl channel. To create a
VTF file, first use \lit{writevsf} at the beginning of the simulation,
and then \texttt{writevcf} after each timestep to generate a
trajectory of the whole simulation.

The structure definitions in the VTF/VSF formats are incremental, \ie
a user can easily add further structure lines to the VTF/VSF file
after a structure block has been written to specify further particle
properties for visualization.

Note that the ids of the particles in \es and VMD may differ. VMD
requires the particle ids to be enumerated continuously without any
holes, while this is not required in \es. When using \lit{writevsf}
and \lit{writevcf}, the \es particle ids are automatically translated
into VMD particle ids. The function \lit{vtfpid} allows the user to
get the VMD particle id for a given \es particle id.

Also note, that these formats can not be used to write trajectories
where the number of particles or their types varies between the
timesteps. This is a restriction of VMD itself, not of the format.

\subsection{\texttt{writevsf}: Writing the topology}
\newescommand{writevsf}

\begin{essyntax}
  writevsf \var{channelId} 
  \opt{\alt{short \asep verbose}}
  \opt{radius \alt{\var{radii} \asep auto}} 
  \opt{typedesc \var{typedesc}}
\end{essyntax}
Writes a structure block describing the system's structure to the
channel given by \var{channelId}. \var{channelId} must be an
identifier for an open channel such as the return value of an
invocation of \keyword{open}.  The output of this command can be used
for a standalone VSF file, or at the beginning of a VTF file that
contains a trajectory of a whole simulation.

\begin{arguments}
\item[\opt{\alt{short \asep verbose}}]
  Specify, whether the output is in a human-readable, but somewhat
  longer format (\keyword{verbose}), or in a more compact form
  (\keyword{short}). The default is \keyword{verbose}.
  
\item[\opt{radius \alt{\var{radii} \asep auto}}] Specify the VDW radii
  of the atoms. \var{radii} is either \keyword{auto}, or a Tcl-list
  describing the radii of the different particle types. When the
  keyword \keyword{auto} is used and a Lennard-Jones interaction
  between two particles of the given type is defined, the radius is
  set to be $\frac{\sigma_{LJ}}{2}$ plus the LJ shift.  Otherwise, the
  radius $0.5$ is substituted. The default is \keyword{auto}.
  \minisec{Example}
  \verb!writevsf $file radius {0 2.0 1 auto 2 1.0}!

\item[\opt{typedesc \var{typedesc}}]
  \var{typedesc} is a Tcl-list giving additional VTF atom-keywords to
  specify additional VMD characteristics of the atoms of the given type.
  If no description is given for a certain particle type, it defaults to
  \texttt{name \textit{name} type \textit{type}}, where \textit{name}
  is an atom name and \textit{type} is the type id.
  \minisec{Example} 
  \verb!writevsf $file typedesc {0 "name colloid" 1 "name pe"}!
\end{arguments}

\subsection{\texttt{writevcf}: Writing  the coordinates}
\newescommand{writevcf}

\begin{essyntax}
  writevcf \var{channelId} 
  \opt{\alt{short \asep verbose}}
  \opt{\alt{folded \asep absolute}}
  \opt{pids \alt{\var{pids} \asep all}}
  \opt{userdata \var{userdata}}
\end{essyntax}
Writes a coordinate (or timestep) block that contains all coordinates
of the system's particles to the channel given by \var{channelId}.
\var{channelId} must be an identifier for an open channel such as the
return value of an invocation of \keyword{open}.

\begin{arguments}
\item[\opt{\alt{short \asep verbose}}] Specify, whether the output is
  in a human-readable, but somewhat longer format (\keyword{verbose}),
  or in a more compact form (\keyword{short}). The default is
  \keyword{verbose}.
  
\item[\opt{\alt{folded \asep absolute}}] Specify whether the particle
  positions are written in absolute coordinates (\keyword{absolute})
  or folded into the central image of a periodic system
  (\keyword{folded}). The default is \keyword{absolute}.
  
\item[\opt{pids \alt{\var{pids} \asep all}}] Specify the coordinates
  of which particles should be written. If \keyword{all} is used, all
  coordinates will be written (in the ordered timestep format).
  Otherwise, \var{pids} has to be a Tcl-list specifying the pids of
  the particles. The default is \keyword{all}.
  \minisec{Example} \verb!pids {0 23 42}!

\item[\opt{userdata \var{userdata}}] Specify arbitrary user data for
  the particles. \var{userdata} has to be a Tcl list containing the
  user data for every particle. The user data is appended to the
  coordinate line and can be read into VMD via the VMD plugin
  \texttt{VTFTools}. The default is to provide no userdata.
  \minisec{Example} \verb!userdata {"red" "blue" "green"}!
\end{arguments}


\subsection{\texttt{vtfpid}: Translating \es particles ids to VMD
  particle ids}
\begin{essyntax}
  vtfpid \var{pid}
\end{essyntax}
If \var{pid} is the id of a particle as used in \es, this command
returns the atom id used in the VTF, VSF or VCF formats.

\section{\texttt{writevtk}: Particle Visualization in paraview}
\label{sec:writevtk}
\newescommand{writevtk}

This feature allows to export the particle positions in a paraview
\footnote{\url{http://www.paraview.org/}} compatible VTK
file. Paraview is a powerful and easy to use open-source visualization
program for scientific data. Since \es can export the
lattice-Boltzmann velocity field \ref{ssec:LBvisualization} in the VTK
format as well and paraview allows to visualize particles with glyphs
and vector fields with stream lines, glyphs, contourplots, etc., one
can use it so completely visualize a coupled lattice-Boltzmann MD
simulation. It can also create videos without much effort if one
exports data of individual time steps into separate files with
filenames including a running index (\texttt{data_0.vtk},
\texttt{data_1.vtk}, ...).

\begin{essyntax}
  writevtk \var{filename} 
  \opt{\alt{all \asep \var{types}}}
\end{essyntax}

\begin{arguments}
\item[\var{filename}]
  Name of the file to export the particle positions into.
\item[\opt{\alt{all \asep \var{type}}}] Specifies a list of particle
  types which should be exportet. The default is
  \keyword{all}. Alternatively, a list of type number can be
  given. Exporting the positions of all particles but in separate
  files might make sense if one wants to distinguish the different
  particle types in the visualization (i.e. by color or size).  To
  export a type \texttt{1} use something along \texttt{writevtk
    "test.tcl" "1"}.  To export types \texttt{1}, \texttt{5},
  \texttt{7}, which are not to be distinguished in the visualization,
  use \texttt{writevtk "test.tcl" "7 1 5"}.  The order in the list is
  arbitrary, but duplicates are \emph{not} ignored!
\end{arguments}

\section{Reading and Writing PDB/PSF files}
The PDB (Brookhaven Protein DataBase) format is a widely used format
for describing atomistic configurations. PSF is a format that is used
to describe the topology of a PDB file. 

When visualizing your system with VMD, it is recommended to use the
VTF format instead (see section \ref{sec:vtf}), as it was specifically
designed for visualizations with VMD. In contrast to the PDB/PSF
formats, in VTF files it is possible to specify the VDW radii of the
particles, to have a varying simulation box size, etc.

\subsection{\lit{writepsf}: Writing the topology}
\newescommand{writepsf}

\begin{essyntax}
  writepsf \var{file} \opt{-molecule} \var{N_P} \var{MPC} \var{N_CI}
  \var{N_pS} \var{N_nS}
\end{essyntax}
Writes the current topology to the file \var{file} (here, \var{file}
is not a channel, since additional information cannot be written
anyway).  \var{N_P}, \var{MPC} and so on are parameters describing a
system consisting of equally long charged polymers, counterions and
salt.  This information is used to set the residue name and can be
used to color the atoms in VMD. If you specify \lit{-molecule}, the
residue name is taken from the molecule identity of the particle. Of
course different kinds of topologies can also be handled by modified
versions of \lit{writepsf}.


\subsection{\lit{writepdb}: Writing the coordinates}
\newescommand{writepdb}
\newescommand{writepdbfoldchains}
\newescommand{writepdbfoldtopo}

\begin{essyntax}
  \variant{1} writepdb \var{file}
  \variant{2} writepdbfoldchains \var{file} \var{chain\_start}
  \var{n\_chains} \var{chain\_length} \var{box\_l}
  \variant{3} writepdbfoldtopo \var{file} \var{shift}
\end{essyntax}

Variant \variant{1} writes the corresponding particle data. 

Variant \variant{2} writes folded particle data where the folding is
performed on chain centers of mass rather than single particles. In
order to fold in this way the chain topology and box length must be
specified.  Note that this method is outdated. Use variant \variant{3}
instead.

Variant \variant{3} writes folded particle data where the folding is
performed on chain centers of mass rather than single particles. This
method uses the internal box length and topology information from
espresso. If you wish to shift particles prior to folding then supply
the optional shift information. \var{shift} should be a three member
tcl list consisting of x, y, and z shifts respectively and each number
should be a floating point (ie with decimal point).

\subsection{\lit{readpdb}: Reading the coordinates and interactions}
\newescommand{readpdb}

\begin{essyntax}
  readpdb pdb_file \var{pdbfile} type \var{type} first_id \var{firstid} \opt{
  itp_file \var{itpfile} first_type \var{fisttype}} \\
  \opt{\require{1}{lj_with \var{othertype} \var{epsilon} \var{sigma}}}
  \opt{\require{1}{lj_rel_cutoff \var{cutoff}} } \opt{fit_to_box}
\begin{features}
  \required[1]{LENNARD_JONES}
\end{features}
\end{essyntax}
Reads the positions and possibly charges, types and Lennard-Jones interactions
from the file \var{pdbfile} and a corresponding Gromacs topology file \var{itpfile}.
The topology file must contain the \verb|atoms| and \verb|atomtypes| sections,
it may be necessary to use the Gromacs preprocessor to obtain a complete file
from a system configuration and a force field.

Any offset of the particle positions if removed, such that the lower left
corner bounding box of the particles is in the origin. If \verb|fit_to_box| is
given, the box size if increased to hold the particles if necessary. If it is
not set and the particles do not fit into the box, the behavior is undefined.

\var{type} sets the particle type for the added particles. 
If there is a topology file give that contains a types for the particles, 
the particles get types by the order in the topology file plus \var{firstype}.
If the corresponding type in the topology file has a charge, it is used,
otherwise the particle charge defaults to zero.

The particles get consecutive id's in the order of the pdb file, starting at
\var{firstid}. Please be aware that existing particles get overwritten by
values from the file.

The \verb|lj_with| section produces Lennard-Jones interactions between the
type \var{othertype} and the types defined by the topology file. The
interaction parameters are calculated as $\epsilon_{\text{othertype},j} =
\sqrt{\epsilon_{\text{othertype}} \epsilon_j}$ and $\sigma_{\text{othertype},j}
=\frac{1}{2}\left( \sigma_{\text{othertype}} + \sigma_j \right)$, where $j$
runs over the atomtypes defined in the topology file. This corresponds to the
combination rule 2 of Gromacs. There may be multiple such sections.
The cutoff is determined by \var{cutoff} as $\text{cutoff}\times \sigma_{ij}$ in a
relative fashion. The potential is shifted so that it vanishes at the cutoff.
The command returns the number of particles that were successfully added.

Reading bonded interactions and dihedrals is currently not supported.

\section{Online-visualisation with VMD}
\label{sec:IMD}
\index{IMD}

IMD (Interactive Molecular Dynamics) is the protocol that VMD uses to
communicate with a simulation. Tcl\_md implements this protocol to
allow online visual analysis of running simulations.

In IMD, the simulation acts as a data server. That means that a
simulation can provide the possibility of connecting VMD, but VMD need
not be connected all the time. You can watch the simulation just from
time to time.

In the following the setup and usage of IMD is described.

\subsection{\texttt{imd}: Using IMD in the script}
\newescommand{imd}

\begin{essyntax}
  \variant{1} imd connect \opt{\var{port}}
  \variant{2} imd positions \opt{\alt{-unfolded \asep -fold_chains}}
  \variant{3} imd listen \var{seconds}
  \variant{4} imd disconnect
\end{essyntax}

In your simulation, the IMD connection is setup up using variant
\variant{1}, where \var{port} is an arbitrary port number (which
usually has to be between 1024 and 65000). By default, \es will try to
open port $10000$, but the port may be in use already by another \es
simulation. In that case it is a good idea to just try another port.

While the simulation is running, variant \variant{2} can be used to
transfer the current coordinates to VMD, if it is connected.  If not,
nothing happens and the command just consumes a small amount of CPU
time. Note, that before you can transfer coordinates to VMD, VMD needs
to be aware of the structure of the system. For that, you first need
to load a corresponding structure file (PSF or VSF) into VMD. Also
note, that the command \lit{prepare_vmd_connection} (see section
\vref{tcl:prepare-vmd-connection}) can be used to automatically set up
the VMD connection and transfer the structure file.

By specifying \lit{-unfolded}, the unfolded coordinates of the
particles will transferred, while \lit{-fold_chains} will fold chains
according to their centers of mass and retains bonding connectivity.
Note that this requires the chain structure to be specified first
using the analyze command.

Variant \variant{3} can be used to let the simulation wait for
\var{seconds} seconds or until IMD has connected, before the script is
continued. This is normally only useful in demo scripts, if you want
to see all frames of the simulation.

Variant \variant{4} will terminate the IMD session. This is normally
not only nice but also the operating system will not free the port for
some time, so that without disconnecting for some 10 seconds you will
not be able to reuse the port.

\subsection{Using IMD in VMD}

The PDB/PSF files created by \es via the command \lit{writepsf} and
\lit{writepdb} can be loaded into VMD. This should bring up an initial
configuration.

Then you can use the VMD console to execute the command
\begin{code}
  imd connect \var{host} \var{port}
\end{code}
where \var{host} is the host running the simulation and \var{port} is
the port it listens to. Note that VMD crashes, if you do that without
loading a structure file before.  For more information on how to use
VMD to extract more information or hide parts of configuration, see
the VMD Quick Help.

\subsection{Automatically setting up a VMD connection}
\newescommand[prepare-vmd-connection]{prepare_vmd_connection}

\begin{essyntax}
\variant{1} prepare_vmd_connection 
\var{filename} \opt{start} \opt{wait \var{wait}} \opt{localhost}
\opt{constraints}
...
\variant{2} prepare_vmd_connection 
\opt{\var{filename} \opt{\var{wait} \opt{\var{start} \opt{\var{constraints}}}}}
\end{essyntax}

To reduce the effort involved in setting up the IMD connection,
starting VMD and loading the structure file, \es provides the command
\lit{prepare_vmd_connection}.  It writes out the required
vsf structure description file to \var{filename}.vsf (default
for \var{filename} is \lit{vmd}), doing some nice stuff such as
coloring the molecules, bonds and counterions appropriately, rotating
your viewpoint, and connecting your system to the visualization
server.

If the option \opt{constraints} is given, then the command will create
graphics primitives in VMD that represent some of the spatial
constraints (sphere, rhomboid and cylinder at present).

If \opt{start} is given, the command will automatically try to start VMD and connect it to the \es{} simulation.  Otherwise it only writes the VMD
setup script \lit{\var{filename}.vmd_start.script}. You can use this script later to connect to the \es{} simulation by running either
\begin{code}
  vmd -e vmd_start.script
\end{code}
or by running
\begin{code}
  source "vmd\_start.script"
\end{code}
at VMD's Tcl console. If you choose to not start VMD automatically,
\lit{prepare_vmd_connection} puts the hostname into the VMD script, so
that you can start it from any computer. However, some more recent Linux
distributions block any incoming transfer even from the computer itself,
if it does not come from localhost. If you encounter problems to connect
to VMD on the very same computer, try the \opt{localhost} option, which
will enforce to use the hostname \lit{localhost}. Note that the \opt{start} option implies the \opt{localhost} option, since VMD is
necessarily started from the same computer.

If the option \opt{wait} is provided, then the command waits for at most
\var{wait} seconds for VMD to connect. Since VMD usually takes a while
to start, it is usually a good idea to combine the \opt{start} option with a waiting time of 100, so a bit less than a minute.

All remaining parameters are passed to the \lit{writevsf} that is used
to setup the system, so that you can specify the sizes of particles etc.

\lit{prepare_vmd_connection} also supports an older, deprecated syntax (variant 2) with limited functionality. This syntax uses fixed position
parameters and boolean values for \opt{start} and \opt{constraints}, as
described above.

\section{Writing H5MD-files}
For large amounts of data it's a good idea to store it in the hdf5 (H5MD is
based on hdf5) file format
(see \url{https://www.hdfgroup.org/} for details). \es currently supports
some basic functions for writing simulation data to H5MD files.
\subsection{\keyword{h5md_init}: Initialize a H5MD data file}

\begin{essyntax}
h5md_init
\var{/where/to/store/data/file}
    \begin{features}
    \required{H5MD}
    \end{features}
\end{essyntax}
The \codebox{h5md_init} command initializes the H5MD file and creates 
groups and datasets according to the conventions of H5MD (see
\url{http://nongnu.org/h5md/}). If a H5MD file already exists at the given
path it will be opened and you can append data it.

\subsection{\keyword{h5md_write_positions}: Write particle positions to H5MD
file}

\begin{essyntax}
h5md_write_positions
\opt{folded}
  \begin{features}
  \required{H5MD}
  \end{features}
\end{essyntax}
Writes the positions of all particles to the dataset which was previously 
initialized by \texttt{h5md_init}.

\subsection{\keyword{h5md_write_velocities}: Write particle velocities to H5MD
file}

\begin{essyntax}
h5md_write_velocities
  \begin{features}
  \required{H5MD}
  \end{features}
\end{essyntax}
Writes the velocities of all particles to the dataset which was previously 
initialized by \texttt{h5md_init}.

\begin{essyntax}
h5md_write_forces
  \begin{features}
  \required{H5MD}
  \end{features}
\end{essyntax}
Writes the forces of all particles to the dataset which was previously 
initialized by \texttt{h5md_init}.

\subsection{\keyword{h5md_observable1D_init}: Initialize a user-defined H5MD
observable}

\begin{essyntax}
h5md_observable1D_init \var{name\_of\_observable}
  \begin{features}
  \required{H5MD}
  \end{features}
\end{essyntax}
Initializes an observable dataset with given name in the H5MD file previously
initialized by \texttt{h5md_init}.

\subsection{\keyword{h5md_observable1D_write}: Write to a user-defined H5MD
dataset}

\begin{essyntax}
h5md_observable1D_write \var{name\_of\_observable} \var{value}
  \begin{features}
  \required{H5MD}
  \end{features}
\end{essyntax}
Writes \texttt{value} to a user-defined observable dataset with given name.

\subsection{\keyword{h5md_close}: Close H5MD file}

\begin{essyntax}
h5md_close
  \begin{features}
  \required{H5MD}
  \end{features}
\end{essyntax}
Closes the H5MD data file.


\section{Writing H5MD-files with Python}
To write data in a hdf5-file, first an object of the class \texttt{h5md} has to be created and linked to the respective hdf5-file. This may, for example, look like:
\begin{pycode}
from espressomd import h5md
system = espressomd.System()
h5=h5md.h5md("File.h5",system)
\end{pycode}
The \texttt{h5md} class contains the sub-class \texttt{write_to_h5}, which contains all write commands such as \texttt{userdefined}. The sample python script ``h5md_WriteFile.py'' shows the usage of writing a hdf5-file.

\subsection{\keyword{userdefined}: Write an arbitrary value}
\begin{pyessyntax}
h5.write_to_h5.userdefined(\var{value},\var{groupname},\var{datasetname},\var{datatype},\\\var{datasetindex},\var{chunks})
\end{pyessyntax}
The command \texttt{userdefined} writes the value \var{value} of type \var{datatype} in the hdf5-file. The storage path is given by \var{groupname} and the dataset is called \var{datasetname}. Fragmenting the dataset to smaller units can increase the access speed to the hdf5-file. The dataset can be chunked to smaller dataset sub units with size \var{chunks}. When not defining the chunk size explicitly, it will be set to automatic.
\begin{arguments}
\item[\var{value}] The value to be written.
\item[\var{groupname}] Name of the group, which contains the dataset.
\item[\var{datasetname}] Name of the dataset, which contains the values.
\item[\var{datatype}] The value's data type.
\item[\var{datasetindex}] Position of \var{value} within the dataset.
\item[\var{chunks}] Size of dataset sub units. 
\end{arguments}

\subsection{\keyword{particle_property}: Write particle properties}
\begin{pyessyntax}
h5.write_to_h5.particle_property(\var{timestep},\var{groupname},\var{datasetname},\var{chunks})
\end{pyessyntax}
This command writes particle properties, such as the position, in the hdf5-file for all particles at once. The command \mbox{\texttt{particle_property}} is a short cut for the various particle properties such as \texttt{pos} (position) and \texttt{f} (force). These values are stored at the assigned time-step \var{timestep}. When the values are time-independent set \var{timestep=-1}. When leaving out the variables \var{groupname} and \var{datasetname}, the predefined values of \var{groupname} and \var{datasetname} are used in accordance to the H5MD-format.
\begin{arguments}
\item[\var{timestep}] Time index in the hdf5-file.
\item[\var{groupname}] Name of the group, which contains the dataset.
\item[\var{datasetname}] Name of the dataset, which contains the values.
\item[\var{chunks}] Size of dataset sub units. 
\end{arguments}

\subsection{\keyword{observables}: Write observables}
\begin{pyessyntax}
h5.write_to_h5.observable(\var{timestep},\var{groupname},\var{datasetname},\var{chunks})
\end{pyessyntax}
With this command the various ESPResSo observables can be written. The command \texttt{observable} is a short cut for the various observables such as \texttt{analyze_energy}.
\begin{arguments}
\item[\var{timestep}] Time index in the hdf5-file.
\item[\var{groupname}] Name of the group, which contains the dataset.
\item[\var{datasetname}] Name of the dataset, which contains the values.
\item[\var{chunks}] Size of dataset sub units.
\end{arguments}

\subsection{\keyword{VMD}: Write VMD}
\begin{pyessyntax}
h5.write_to_h5.VMD(\var{datasetname},\var{value})
\end{pyessyntax}
The molecular visualization program VMD can read hdf5-files, when the H5MD-format is applied. To use VMD only the particle positions are needed. For coloring issues VMD can use further datasets. These datasets \var{datasetname} (e.g. 'indexOfSpecies'), with the associated values \var{value}, are written via the \texttt{VMD} command. The datasets are stored in the h5-group "parameters/vmd_structure/". All possible dataset are shown in the example file. 
\begin{arguments}
\item[\var{datasetname}] Name of the dataset, which contains the values.
\item[\var{value}] The value to be written.
\end{arguments}


\section{Reading H5MD-files with Python}
To read data from a hdf5-file, again an object of the class \texttt{h5md} has to be created and linked to the respective hdf5-file. The \texttt{h5md} class contains the sub-class \texttt{read_from_h5}, which contains all read commands such as \texttt{userdefined}. The sample python script ``h5md_ReadFile.py'' shows the usage of reading from a hdf5-file.
\subsection{\keyword{userdefined}: Read an arbitrary value}
\begin{pyessyntax}
h5.read_from_h5.userdefined(\var{groupname},\var{datasetname},\var{datasetindex})
\end{pyessyntax}
The command \texttt{userdefined} reads and returns a value from the hdf5-file positioned at \var{datasetindex}.
\begin{arguments}
\item[\var{groupname}] Name of the group, which contains the dataset.
\item[\var{datasetname}] Name of the dataset, which contains the values.
\item[\var{datasetindex}] Position of \var{value} within the dataset.
\end{arguments}

\subsection{\keyword{particle_property}: Read particle properties}
\begin{pyessyntax}
h5.read_from_h5.particle_property(\var{timestep},\var{groupname},\var{datasetname})
\end{pyessyntax}
This command reads a particle property at time-step \var{timestep} from the hdf5-file and passes the values to the respective ESPResSo variables. The command \mbox{\texttt{particle_property}} is again a short cut for the various particle property commands such as \texttt{pos} and \texttt{f}.
\begin{arguments}
\item[\var{timestep}] Time index in the hdf5-file. 
\item[\var{groupname}] Name of the group, which contains the dataset.
\item[\var{datasetname}] Name of the dataset, which contains the values.
\end{arguments}



\section{Error handling}
Errors in the parameters are detected as early as possible, and
hopefully self-explanatory error messages returned without any changes
to the data in the internal data of \es. This include errors such as
setting nonexistent properties of particles or simply misspelled
commands. These errors are returned as standard Tcl errors and can be
caught on the Tcl level via
\begin{tclcode}
catch {script} err 
\end{tclcode}
When run noninteractively, Tcl will return a nice stack backtrace
which allows to quickly find the line causing the error.

However, some errors can only be detected after changing the internal
structures, so that \es is left in a state such that integration is
not possible without massive fixes by the users. Especially errors
occuring on nodes other than the primary node fall under this
condition, for example a broken bond or illegal parameter
combinations.

\todo{I do not understand this. How does the error look?}
For error conditions such as the examples given above, a Tcl error
message of the form
\begin{code}
\var{tcl\_error} background 0 \var{error\_a} \var{error\_b} 1 \var{error\_c}
\end{code}
is returned. Following possibly a normal Tcl error message, after the
background keyword all severe errors are listed node by node,
preceeded by the node number. A special error is \lit{<consent>},
which means that one of the slave nodes found exactly the same errors
as the master node. This happens mainly during the initialization of
the integrate, \eg if the time step is not set. In this case the error
message will be
\begin{code}
background\_errors 0 \{time\_step not set\} 1 <consent> 
\end{code}
In each case, the current action was not fulfilled, and possibly other
parts of the internal data also had to be changed to allow \es to
continue, so you should really know what you do if you try and catch
these errors.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "ug"
%%% End: 
