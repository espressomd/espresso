% Copyright (C) 2010,2012,2013,2014,2015,2016 The ESPResSo project
% Copyright (C) 2002,2003,2004,2005,2006,2007,2008,2009,2010 
%   Max-Planck-Institute for Polymer Research, Theory Group
%  
% This file is part of ESPResSo.
%   
% ESPResSo is free software: you can redistribute it and/or modify it
% under the terms of the GNU General Public License as published by the
% Free Software Foundation, either version 3 of the License, or (at your
% option) any later version.
%  
% ESPResSo is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.
%  
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
\chapter{Running the simulation}
\label{chap:run}

\section{\texttt{integrate}: Running the simulation}
\newescommand{integrate}

\begin{essyntax}
  \variant{1} integrate \var{steps} \opt{recalc_forces} \opt{reuse_forces}
  \variant{2} integrate set \opt{nvt}
  \variant{3} integrate set npt_isotropic \var{p_{ext}} \var{piston} \opt{\var{x\; y\; z}} \opt{-cubic_box}
\end{essyntax}

\es uses the Velocity Verlet algorithm for the integration of the
equations of motion. The command \texttt{integrate} with an integer
\texttt{steps} as parameter integrates the system for \texttt{steps}
time steps.

Note that this implementation of the Velocity Verlet algorithm reuses forces,
that is, they are computed once in the middle of the time step, but used twice,
at the beginning and end. However, in the first time step after setting up,
there are no forces present yet. Therefore, \es{} has to compute them before the
first time step. That has two consequences: first, random forces are redrawn,
resulting in a narrower distribution of the random forces, which we compensate
by stretching. Second, coupling forces of e.\,g. the Lattice Boltzmann fluid cannot
be computed and are therefore lacking in the first half time step. In order to
minimize these effects, \es{} has a quite conservative heuristics to decide whether
a change makes it necessary to recompute forces before the first time step. Therefore,
calling hundred times \texttt{integrate 1} does the same as \texttt{integrate 100},
apart from some small calling overhead.

However, for checkpointing, there is no way for \es{} to tell that the forces that you
read back in actually match the parameters that are set. Therefore, \es{} would recompute
the forces before the first time step, which makes it essentially impossible to checkpoint
LB simulations, where it is vital to keep the coupling forces. To work
around this, \texttt{integrate}
has an additional parameter \opt{reuse_forces}, which tells integrate to not recalculate
the forces for the first time step, but use that the values still stored with the particles.
Use this only if you are absolutely sure that the forces stored match your current setup!

The opposite problem occurs when timing interactions: In this case,
one would like to recompute the forces, despite the fact that they are
already correctly calculated. To this aim, the option
\opt{recalc_forces} can be used to enforce force recalculation.

Two methods for the integration can be set: For an NVT ensemble
(thermostat) and for an NPT isotropic ensemble (barostat). The current
method can be detected with the command \texttt{integrate set} without
any parameters.

The NVT integrator is set without parameters (the temperature can be
set with the thermostat). For the NPT ensemble, the parameters that
can be added are:

\begin{itemize}
\item \var{p_{ext}} The external pressure as float variable. This
  parameter is required.
\item \var{piston} The mass of the applied piston as float
  variable. This parameter is required.
\item \var{x}:\var{y}:\var{z} Three integers to set the box geometry for
  non-cubic boxes. This parameter is optional.
\item \texttt{-cubic_box} If this optional parameter is added, a cubic
  box is assumed.
\end{itemize}

For systems with the \feature{ROTATION} feature, the integration is done using the
quaternion-based Velocity Verlet scheme by Martys and Mountain~\cite{martys99}.

\section{\texttt{time_integration}: Runtime of the integration loop}
\newescommand[time-integration]{time_integration}

\begin{essyntax}
  \variant{1} time_integration
  \variant{2} time_integration \var{steps}
\end{essyntax}

This command runs the integration as would the \texttt{integrate} command and
returns the wall runtime in seconds.

\section{\texttt{minimize_energy}: Run steepest descent minimization}
\newescommand[minimize-energy]{minimize_energy}

\begin{essyntax}
  \variant{1} minimize_energy \var{f_\mathrm{max}} \var{steps} \var{gamma} \var{maxdisplacement}
\end{essyntax}

\begin{pysyntax}
  \object{
    espressomd.minimize_energy
  }{
    init
  }{
    f_max = \arg{double},
    gamma = \arg{double},
    max_steps = \arg{double},
    max_displacement = \arg{double}
  }
  \object{
    espressomd.minimize_energy
  }{
    minimize
  }{}
  \object{
    System.minimize_energy
  }{
    init
  }{
    f_max = \arg{double},
    gamma = \arg{double},
    max_steps = \arg{double},
    max_displacement = \arg{double}
  }
  \object{
    System.minimize_energy
  }{
    minimize
  }{}
\end{pysyntax}

In Python the minimize\_energy functionality can be imported from \texttt{espressomd}
as class \texttt{MinimizeEnergy}. Alternatively it is already part of the System
class object and can be called from there (second variant). 

This command runs a steepest descent energy minimization on the system.
Please note that the behaviour is undefined if either a thermostat, Maggs electrostatics or Lattice-Boltzmann is activated.
It runs a simple steepest descent algorithm:

Iterate
$$p_i = p_i + \min(\text{\var{gamma}} \times F_i, \text{\var{maxdisplacement}}),$$
while the maximal force is bigger than \var{f_\mathrm{max}} or for at most \var{steps} times.
The energy is relaxed by \var{gamma}, while the change per coordinate per step is limited to \var{maxdisplacement}.
The combination of \var{gamma} and \var{maxdisplacement} can be used to get an poor man's adaptive update.
Rotational degrees of freedom are treated similarly: each particle is rotated around an axis parallel to the torque acting on the particle.
Please be aware of the fact that this needs not to converge to a local minimum in periodic boundary conditions.
Translational and rotational coordinates that are fixed using the ``fix`` command or the ROTATION\_PER\_PARTICLE feature are not altered.

\section{\texttt{tune_skin}: Tune the skin}
\newescommand[tune-skin]{tune_skin}

\begin{essyntax}
  \variant{1} tune_skin \var{min} \var{max} \var{tol} \var{steps}
\end{essyntax}

Determines the fastest skin between \var{min} and \var{max} with tolerance \var{tol}
by bisection. The integration time is determined by timing \var{steps} intergration.
You should chose \var{steps} big engough so that multiple verlet updates occure even
for the \var{max} skin, otherwise the timings are not meaningful. Please be aware that
this command runs actual integrations and propagates the system. In a typical MD simulation
it should be used after warmup and equilibration, in the same conditions where sampling
is done.

\section{\texttt{change_volume}: Changing the box volume}
\newescommand[change-volume]{change_volume}

\begin{essyntax}
  \variant{1} change_volume \var{V_\mathrm{new}} 
  \variant{2} change_volume \var{L_\mathrm{new}} \alt{x \asep y \asep z \asep xyz}
\end{essyntax}
Changes the volume of either a cubic simulation box to the new volume
\var{V_\mathrm{new}} or its given x-/y-/z-/xyz-extension to the new
box-length \var{L_\mathrm{new}}, and isotropically adjusts the
particles coordinates as well. The function returns the new volume of
the deformed simulation box.

\section{\texttt{rotate_system}: Rotating the system around its center of mass}
\newescommand[rotate-system]{rotate_system}

\begin{essyntax}
  \variant{1} rotate_system \var{phi} \var{theta} \var{alpha}
\end{essyntax}

Rotates the particle coordinates around the system's center of mass. This only makes sense for non-periodic boundaries, but no check is performed. 
In addition to the particle positions, the command also rotates the particles themselves, if the ROTATION feature is activated. Hence, dipole moments as well as virtual sites based on the VS\_RELATIVE method will also be affected.
The command only works on a single cpu.

The rotation axis is given by the parameters \var{phi} and \var{theta} as
\begin{equation}
\vec{a} = (\sin \theta \cos \phi ; \sin \theta \sin \phi ; \cos \theta),
\end{equation}
and \var{alpha} denotes the rotation angle.


\section{\texttt{lees_edwards_offset}: Applying shear between periodic images}
\newescommand[lees-edwards-offset]{lees_edwards_offset}
\label{sec:lees-edwards}
\index{Lees-Edwards Boundaries|mainindex}
\index{shear boundaries}
\index{shear viscosity}


\begin{essyntax}
  \variant{1} lees_edwards_offset \var{offset_\mathrm{new}}  
  \begin{features}
    \required{LEES_EDWARDS}
  \end{features}

\end{essyntax}

Lees-Edwards Periodic Boundary Conditions are used to impose a shear flow of speed $\dot{\gamma}$ on the system relative to its periodic images by moving the PBC wrap such that:  $v\_x_{unfolded} =  v\_x_{folded} + \dot{\gamma} y_{img}$ (where $v\_x_{unfolded}$ is the $x$-component of the velocity of an image particle outside the main simulation box, and $y_{img}$ is the count of PBC boundaries crossed in the $y$-direction).  
The absolute value of the shear offset is set using this command; with the shear flow rate $\dot{\gamma}$ then determined internally as the difference between successive offsets.  
A typical usage would be to integrate by 1 {MD} timestep and then to increase the offset to a new value using this command; this usage pattern is intended to allow for arbitrary shear flow time profiles, such as an oscillatory shear.  
A common calculation to make using Lees-Edwards boundary conditions is to find the shear viscosity (or kinematic viscosity) by plotting shear stress (or shear stress/density) against the applied strain for different values of constant $\dot{\gamma}$. 

Lees-Edwards differs from the NEMD approach (see \vref{sec:NEMD}) in that the shear imposed is homogenous across the system (but only on average: symmetry breaking effects are not ruled out) rather than reversing direction with a periodicity of the box length. 
Accordingly the transport properties  measured using Lees-Edwards are likely to be different to (and arguably more physical than) those measured using NEMD or those from equilibrium simulations by a Green-Kubo type approach.

When the shear flow rate $\dot{\gamma}$ is non-zero, the Langevin thermostat will treat $v\_x_{folded}$ as being relative to a flow field which changes smoothly from $-\dot{\gamma}/2$ at the bottom of the periodic box to $\dot{\gamma}/2$ at the top.  
This `laminar' thermostatting is provided mostly because it gives quite convenient equilibration of a flowing system.  In order to correctly observe transport properties, symmetry-breaking or entropy production in relation to shear flow is probably better to use the DPD thermostat (see \vref{sec:DPD}) once the initial heat-up has been carried out.  
The DPD thermostat removes kinetic energy from the system based on a frictional term defined relative to a local reference frame of a given particle-pair, without enforcing any specific flow pattern \textit{a priori}.  At high rates of dissipation, this can however lead to an artefactual  shear-banding type effect at the periodic boundaries, such that the bulk fluid is nearly stationary.  
This effect is removed using the modification proposed to the DPD thermostat by Chatterjee \cite{chatterjee2007} to allow treatment of systems with high dissipation rates, which is applied automatically if \feature{LEES_EDWARDS} is compiled in.  Chatterjee's modification is just to skip calculation of DPD forces (both dissipative and random) for particle pairs which cross a boundary in \textit{y}.

The function returns the old value of the offset.

If \feature{LEES_EDWARDS} is compiled in, then coordinates are folded into the primary simulation box as the integration progresses, to prevent a numerical overflow.  

\section{Stopping particles}

Use the following functions, also see Section~\ref{sec:Galilei}:
\begin{itemize}
\item \texttt{kill\_particle\_motion}: halts all particles in the
  current simulation, setting their velocities to zero, as well as
  their angular momentum if the feature ROTATION has been compiled in.
\item \texttt{kill\_particle\_forces}: sets all forces on the
  particles to zero, as well as all torques if the feature ROTATION
  has been compiled in.
\end{itemize}

\section{\texttt{velocities}: Setting the velocities}
\newescommand{velocities}
\begin{essyntax}
  velocities \var{v_\mathrm{max}} 
  \opt{start \var{pid}} 
  \opt{count \var{N}}
\end{essyntax}
Sets the velocities of the particles with particle IDs between
\var{pid} and $\var{pid}+\var{N}$ to a random vector with a length
less than \var{v_\mathrm{max}}, and returns the absolute value of the
total velocity assigned. By default, all particles are affected.

\section{Fixing the particle sorting}
\newescommand[sort-particles]{sort_particles}
\begin{essyntax}
  sort_particles
\end{essyntax}

Resorts the particles, making sure that
\begin{itemize}
\item the domain decomposition is strictly fullfilled, \ie{} each
   particle is on the processor and in the cell that its
   position belongs to
\item the particles within each cell are ordered with ascending
identity.
\end{itemize}
Both conditions together form a unique particle ordering. This is
important when doing checkpointing, because this makes sure that
random numbers are applied in a specific order. Therefore, after
writing or reading a checkpoint, you should call \texttt{sort_particles}.

\section{Parallel tempering}
\newescommand[parallel-tempering]{parallel_tempering}
\begin{essyntax}
  parallel_tempering::main
  -rounds \var{N}
  -swap \var{swap}
  -perform \var{perform}
  \opt{-init \var{init}}
  \opt{-values \var{\{T_i\}}}
  \opt{-connect \var{master}}
  \opt{-port \var{port}}
  \opt{-load \var{j_\mathrm{node}}}
  \opt{-resrate \var{N_\mathrm{reset}}}
  \opt{-info \var{info}}
\end{essyntax}

This command can be used to run a parallel tempering simulation. Since the simulation routines and
the calculation of the swap probabilities are provided by the user, the method is not limited to
sampling in the temperature space. However, we assume in the following that the sampled values are
temperatures, and call them accordingly. It is possible to use multiple processors via TCP/IP
networking, but the number of processors can be smaller than the number of temperatures.

\begin{arguments}
\item[\var{swap}] specifies the name of the routine calculating the
  swap probability for a system. The routine has to accept three
  parameters: the \var{id} of the system to evaluate, and two
  temperatures \var{T_1} and \var{T_2}. The routine should return a
  list containing the energy of the system at temperatures \var{T_1}
  and \var{T_2}, respectively.
\item[\var{perform}] specifies the name of the routine performing the
  simulation between two swap tries. The routine has to accept two
  parameters: the \var{id} of the system to propagate and the
  temperature \var{T} at which to run it. Return values are ignored.
\item[\var{init}] specifies the name of a routine initializing a
  system. This routine can for example create the particles, perform
  some intial equilibration or open output files.  The routine has to
  accept two parameters: the \var{id} of the system to initialize and
  its initial temperature \var{T}. Return values are ignored.
\item[\var{R}] specifies the number of swap trial rounds; in each
  round, neighboring temperatures are tried for swapping
  alternatingly, i.e. with four temperatures, The first swap trial
  round tries to swap $1\leftrightarrow 2$ and $3\leftrightarrow 4$,
  the second round $2\leftrightarrow 3$, and so on.
\item[\var{master}] the name of the host on which the
  parallel_tempering master node is running.
\item[\var{port}] the TCP/IP port on which the parallel_tempering
  master should listen. This defaults to 12000.
\item[\var{j_\mathrm{node}}] specifies how many systems to run per
  \es{}-instance. If this is more than 1, it is the user's
  responsibility to manage the storage of configurations, see below
  for examples.  This defaults to 1.
\item[\var{R_\mathrm{reset}}] specifies after how many swap trial
  rounds to reset the counters for the acceptance rate statistics.
  This defaults to 10.
\item[\var{info}] specifies which output the parallel tempering code
  should produce:
  \begin{itemize}
  \item[\texttt{none}] parallel tempering will be totally quiet,
    except for fatal errors
  \item[\texttt{comm}] information on client activities, such as
    connecting, is printed to stderr
  \item[\texttt{all}] print lots of information on swap energies and
    probabilities to stdout. This is useful for debugging and quickly
    checking the acceptance rates.
  \end{itemize}
  This defaults to \texttt{all}.
\end{arguments}

\subsubsection{Introduction}

The basic idea of parallel tempering is to run $N$ simulations with configurations $C_i$ in
parallel at different temperatures $T_1<T_2<\hdots<T_N$, and exchange configurations between
neighboring temperatures. This is done according to the Boltzmann rule, \ie the swap probability
for two configurations A and B at two different parameters $T_1$ and $T_2$ is given by
\begin{equation}
  \label{eq:ptacceptance}
  \min\left(1,\exp -\left[\beta(T_2)U_\text{A}(T_2) + \beta(T_1)U_\text{B}(T_1) -
    \beta(T_1)U_\text{A}(T_1) - \beta(T_2)U_\text{B}(T_2)\right]\right),
\end{equation}
where $U_C(T)$ denotes the potential energy of configuration $C$ at parameter $T$ and $\beta(T)$
the corresponding inverse temperature. If $T$ is the temperature, $U_C$ is indepedent of $T$, and
$\beta(T)=1/(k_BT)$. In this case, the swap probability reduces to the textbook result
\begin{equation}
  \min(1,\exp -\left[\left(1/T_2 - 1/T_1\right)\left(U_\text{A} - U_\text{B}\right)/k_B\right].
\end{equation}
However, $T$ can also be chosen to be any other parameter, for example the Bjerrum length, \ie the
the strength of the electrostatic interaction. In this case, $\beta(T)=\beta$ is a constant, but
the energy $U_C(T)$ of a configuration $C$ depends on $T$, and one needs the full
expression~\eqref{eq:ptacceptance}. \es{} always uses this expression.

In practice, one does not swap configurations, but temperatures, simply because exchanging
temperatures requires much less communication than exchanging the properties of all particles.

Th \es{} implementation of parallel tempering repeatedly propagates all configurations $C_i$ and
tries to swap neighboring temperatures. After the first propagation, the routine attempts to swap
temperatures $T_1$ and $T_2$, $T_3$ and $T_4$, and so on. After the second propagation, swaps are
attempted between temperatures $T_2$ and $T_3$, $T_4$ and $T_5$, and so on.  For the propagation,
parallel tempering relies on a user routine; typically, one will simply propagate the configuration
by a few 100 MD time steps.

\subsubsection{Details on usage and an example}

The parallel tempering code has to be loaded explicitely by \texttt{source
  "scripts/parallel_tempering.tcl"} from the Espresso directory. To make use of the parallel
tempering tool, one needs to implement three methods: the propagation, the energy calculation and
an initialization routine for a configuration. A typical initialization routine will look roughly
like this:
\begin{verbatim}
proc init {id temp} {
  # create output files for temperature temp
  set f [open "out-$temp.dat" w]; close $f
  init_particle_positions
  thermostat langevin $temp 1.0
  equilibration_integration
  global config
  set config($id) "{[part]} [setmd time]"
}
\end{verbatim}
The last two lines are only necessary if each instance of \es{} handles more than one
configuration, \eg if you have 300 temperatures, but only 10 \es{} processes
(\ie \texttt{-load 30}).  In this case, all
user provided routines need to save and restore the configurations. Saving the time is not
necessary because the simulation tine across swaps is not meaningful anyways; it is however
convenient for investigating the (temperature-)history of individual configurations.

A typical propagation routine accordingly looks like this
\begin{verbatim}
proc perform {id temp} {
  global config
  particle delete
  foreach p [lindex $config($id) 0] { eval part $p }
  setmd time [lindex $config($id) 1]
  thermostat langevin $temp 1.0
  set f [open "out-$temp.dat" a];
  integrate 1000
  puts $f "[setmd time] [analyze energy]"
  close $f
  set config($id) "{[part]} [setmd time]"
}
\end{verbatim}
Again, the saving and storing of the current particle properties in the config array are only
necessary if there is more than one configuration per process. In practice, one will rescale the
velocities at the beginning of perform to match the current temperature, otherwise the thermostat
needs a short time to equilibrate. The energies necessary to determine the swap probablility are
calculated like this:
\begin{verbatim}
proc swap {id temp1 temp2} {
  global config
  particle delete
  foreach p $config($id) { eval part $p }
  set epot [expr [analyze energy total] - [analyze energy kinetic]]
  return "[expr $epot/$temp1] [expr $epot/$temp2]"
}
\end{verbatim}
% make emacs happy: $
Note that only the potential energy is taken into account. The temperature enters only indirectly
through the inverse temperature prefactor, see Eqn.~\eqref{eq:ptacceptance}.

The simulation is then started as follows. One of the processes runs the command
\begin{verbatim}
for {set T 0} {$T < 3} {set T [expr $T + 0.01]} {
    lappend temperatures $T }
parallel_tempering::main -load 30 -values $temperatures -rounds 1000 \
    -init init -swap swap -perform perform
\end{verbatim}
This command turns the \es instance executing it into the master part of the parallel tempering
simulation. It waits until a sufficient number of clients has connected. This are additional \es{}
instances, which are identical to the master script, except that they execute
\begin{verbatim}
parallel_tempering::main -connect $host -load 30 \
    -init init -swap swap -perform perform
\end{verbatim}
% make emacs happy: $
Here, \texttt{host} is a variable containing the TCP/IP hostname of the computer running the master
process. Note that the master process waits until enough processes have connected to start the
simulation. In the example, there are 300 temperatures, and each process, including the master
process, will deal with 30 of them. Therefore, 1 master and 9 slave processes are required. For a
typical queueing system, a starting routine could look like this:
\begin{verbatim}
master=
for h in $HOSTS; do
  if [ "$master" == "" ]; then
    ssh $h "cd run; ./pt_test.tcl"
    master=$h;
  else
    ssh $h "cd run; ./pt_test.tcl -connect $host"
  fi
done
\end{verbatim}
where \texttt{pt_test.tcl} passes the \texttt{-connect} option on to \texttt{parallel_tempering::main}.

\subsubsection{Sharing data}

\begin{essyntax}
  parallel_tempering::set_shareddata \var{data}
\end{essyntax}

can be used at any time {\em by the master process} to specify additional data that is available on
all processes of the parallel_tempering simulation. The data is accessible from all processes as
\texttt{parallel_tempering::shareddata}.

\section{Metadynamics}
\newescommand[metadynamics]{metadynamics}

\begin{essyntax}
  \variant{1} metadynamics 
  \variant{2} metadynamics set off
  \variant{3} metadynamics set distance \var{pid_1} \var{pid_2} \
  \var{d_\mathrm{min}} \var{d_\mathrm{max}} \var{b_\mathrm{height}} \
  \var{b_\mathrm{width}} \var{f_\mathrm{bound}} \var{d_\mathrm{bins}} \var{numrelaxationsteps}
  \variant{4} metadynamics set relative_z \var{pid_1} \var{pid_2} \
  \var{z_\mathrm{min}} \var{z_\mathrm{max}} \var{b_\mathrm{height}} \
  \var{b_\mathrm{width}} \var{f_\mathrm{bound}} \var{z_\mathrm{bins}} \var{numrelaxationsteps}
  \variant{5} metadynamics print_stat current_coord
  \variant{6} metadynamics print_stat coord_values
  \variant{7} metadynamics print_stat profile
  \variant{8} metadynamics print_stat force
  \variant{9} metadynamics load_stat \var{profile\_list} \
  \var{force\_list}

  Required features: METADYNAMICS
\end{essyntax}
Performs metadynamics sampling. Metadynamics is an efficient scheme to
calculate the potential of mean force of a system as a function of a
given reaction coordinate from a canonical simulation. The user first
chooses a reaction coordinate (\eg \texttt{distance}) between two
particles (\var{pid_1} and \var{pid_2}). As the system samples values
along this reaction coordinate (here the distance between \var{pid_1}
and \var{pid_2}), an iterative biased force pulls the system away from
the values of the reaction coordinate most sampled. Ultimately, the
system is driven in such a way that it self-diffuses along the
reaction coordinate between the two boundaries (here
\var{d_\mathrm{min}} and \var{d_\mathrm{max}}). The potential of mean
force (or free energy profile) can be extracted by reading the
\texttt{profile}. 

\begin{arguments}
\item[\var{pid_1}] ID of the first particle involved in the
  metadynamics scheme.
\item[\var{pid_2}] ID of the second particle involved in the
  metadynamics scheme.
\item[\var{d_\mathrm{min}}, \var{z_\mathrm{min}}]: minimum value of
  the reaction coordinate. While \var{d_\mathrm{min}} must be positive
  (it's a distance), \var{z_\mathrm{min}} can be negative since it's
  the relative height of \var{pid_1} with respect to \var{pid_2}.
\item[\var{d_\mathrm{max}}, \var{z_\mathrm{max}}]: maximum value of
  the reaction coordinate. 
\item[\var{b_\mathrm{height}}] height of the bias function.
\item[\var{b_\mathrm{width}}] width of the bias function.
\item[\var{f_\mathrm{bound}}] strength of the ramping force at the
  boundaries of the reaction coordinate interval.
\item[\var{d_\mathrm{bins}}, \var{z_\mathrm{bins}}]: number of bins of
  the reaction coordinate. This is only used for the numerical evaluation of the bias function.
\item[\var{numrelaxationsteps}] number of relaxation steps before setting a new hill. 
\item[\var{profile\_list}] Tcl list of a previous metadynamics
  profile.
\item[\var{force\_list}] Tcl list of a previous metadynamics force.
\end{arguments}

\subsubsection{Details on usage}

Variant \variant{1} returns the status of the metadynamics
routine. Variant \variant{2} turns metadynamics off (default
value). Variant \variant{3} sets a metadynamics scheme with the
reaction coordinate \texttt{distance}, which corresponds to the
distance between any two particles of the system (\eg calculate the
potential of mean force of the end-to-end distance of a
polymer). Variant \variant{4} sets a metadynamics scheme with the
reaction coordinate \texttt{relative_z}: relative height (\ie z
coordinate) of particle \var{pid_1} with respect to \var{pid_2} (\eg
calculate the potential of mean force of inserting one particle
\var{pid_1} through an interface with center of mass
\var{pid_2}). Variant \variant{5} prints the current value of the
reaction coordinate. Variant \variant{6} prints a list of the binned
values of the reaction coordinate (\eg \var{d_\mathrm{bins}} values
between \var{d_\mathrm{min}} and \var{d_\mathrm{max}}). Variant
\variant{7} prints the current potential of mean force for all values
of the reaction coordinate considered. Variant \variant{8} prints the
current force (norm rather than vector) for all values of the reaction
coordinate considered. Variant \variant{9} loads a previous
metadynamics sampling by reading a Tcl list of the potential of mean
force and applied force. This is especially useful to restart a
simulation.

Note that the metadynamics scheme works seamlessly with the
VIRTUAL_SITES feature, allowing to define centers of mass of groups of
particles as end points of the reaction coordinate. One can therefore
measure the potential of mean force of the distance between a particle
and a \emph{molecule} or \emph{interface}.

The metadynamics scheme has (as of now) only been implemented for one
processor: MPI usage is \emph{not} supported. However, one can speed up
sampling by communicating the \texttt{profile} and \texttt{force}
between independent simulations (denoted \emph{walkers}). The
\texttt{print_stat} and \texttt{load_stat} can be used to input/output
metadynamics information between walkers at regular
intervals. Warning: the information extracted from \texttt{print_stat}
contains the entire history of the simulation, while only the
\emph{last} increment of sampling should be communicated between
walkers in order to avoid counting the same samples multiple times.

\subsubsection{Details on implementation}

As of now, only two reaction coordinates have been implemented:
\texttt{distance} and \texttt{relative_z}. Many different reaction
coordinates can be set up, and it is rather easy to implement new
ones. See the code in \texttt{metadynamics.\{h,c\}} for further
details. 

The bias functions that are applied to the potential of mean force and
the biased force are not gaussian function (as in many metadynamics
codes) but so-called Lucy functions. See \cite{marsili09} for more
details. These avoid the calculation of exponentials.

\section{Multi-timestepping}
\newescommand[multitimestepping]{multitimestepping}

\begin{essyntax}
  setmd smaller\_time\_step 0.001 \\
  part $i$ smaller\_timestep 1

  Required features: MULTI\_TIMESTEP
\end{essyntax}

The multi-timestepping integrator allows to run two concurrent integration time
steps within a simulation, associating beads with either the large
\var{time\_step} or the other \var{smaller\_time\_step}.  Setting
\var{smaller\_time\_step} to a positive value turns on the multi-timestepping
algorithm.  The ratio \var{time\_step}/\var{smaller\_time\_step} \emph{must} be
an integer.  Beads are by default associated with \var{time\_step},
corresponding to the particle property \var{smaller\_timestep} 0.  Setting
\var{smaller\_timestep} to 1 associate the particle to the
\var{smaller\_time\_step} integration.  The integrator can be used in the NVE
ensemble, as well as with the Langevin thermostat and the modified Andersen
barostat for NVT and NPT simulations, respectively.  See \cite{bereau15} for
more details.

\section{Reaction Ensemble}
OUTDATED, Please remove as soon as possible. Do not modify. Only work with the sphinx documentation.
% Introduction: notation and terminology
The reaction ensemble~\cite{smith94a} allows to simulate chemical reactions which can be represented by the general equation:
% PK: in chemical equations, elements or chemical formulas are typeset in Roman font. 
% The straightforward way to avoid excessive $ is to enclose the whole chemical equation in \mathrm{}
\begin{equation}
	\mathrm{\nu_1 S_1 +\ \dots\  \nu_l S_l\ \rightleftharpoons\ \nu_m S_m +\ \dots\ \nu_z S_z } \,,
	\label{general-eq}
\end{equation}
where $\nu_i$ is the stoichiometric coefficient of species $\mathrm{S}_i$.  By
convention, stiochiometric coefficents of he species on the left-hand side of
Eq.\ref{general-eq} (\emph{reactants}) attain negative values, and those on the
right-hand side (\emph{products}) attain positive values, so that
Eq.\ref{general-eq} can be equivalently written as
\begin{equation}
	\mathrm{\sum_i \nu_i S_i = 0} \,.
	\label{general-eq-sum}
\end{equation}
The equilibrium constant of the reaction is then given as
\begin{equation}
	K = \exp(-\Delta_{\mathrm{r}}G / RT)
	\quad\text{with}\quad
	\Delta_{\mathrm{r}}G^{\ominus} = \sum_i \nu_i \mu_i^{\ominus}\,.
	\label{Keq}
\end{equation}
Here $R$ is the universal gas constant, $T$ is temperature,
$\Delta_{\mathrm{r}}G^{\ominus}$ standard Gibbs free energy change of the
reaction, and $\mu_i^{\ominus}$ the standard Chemical potential of species $i$.
Note that thermodynamic equilibrium is independent of the direction in which we
write Eq.\ref{general-eq}.  If it is written with left and righ-hand side
swapped, the stoichiometric coefficients and $\Delta_{\mathrm{r}}G^{\ominus}$
attain opposite signs, and the equilibrium constant attains the inverse value.
Further, note that the equilibrium constant $K$ in Eq.\ref{Keq} is the dimensionless
\emph{thermodynamic} equilibrium constant $K_\mathrm{p}$.  Apparent,
concentration-based equilibrium constants can also be found in literature.  To
be used as input for the reaction ensemble, they need to be converted to
thermodynamic constants as described in texbooks of Physical Chemistry.
As a special case, all stoichiometric coefficients on one side
of Eq.\ref{general-eq} can be zero. Such reaction is equivalent
to exchange with a reservoir, and the simulation in reaction ensemble becomes equivalent
with the grandcanonical simulation.
% PK: the text below needs to be revised. Let's comment it out for now
%However, the reaction ensemble is a more general
%scheme, since it allows also for the chemical conversion of species which are not being
%exchanged in the reservoir. Therefore it allows for simulations of a closed
%system, or of a system enclosed by a semi-permeable membrane, where some
%species are exchanged with the reservoir while others are not.

% How RxMC works -- introduce forward and reverse direction, extent of reaction and write the formula for acceptance probability
A simulation in the reaction ensemble consists of two types of moves: the reaction move and the configuration move.
The configuration move is carried out by a suitable molecular dynamics or a Monte
Carlo scheme. The \verb!reacton_ensemble! command of {\es} takes care only of
the reaction moves.  In the \emph{forward} reaction, the appropriate number of
reactants (given by $\nu_i$) is removed
from the system, and the concomitant number of products 
is inserted into the system. In the \emph{reverse} reaction, 
reactants and products exchange their roles. The acceptance probability 
$P^{\xi}$ for move from state $o$ to $n$ reaction ensemble is given by the criterion~\cite{smith94a}
\begin{equation}
	P^{\xi} = \text{min}\biggl(1,V^{\bar\nu\xi}\Gamma^{\xi}e^{-\beta\Delta U}\prod_{i=1}\frac{N_i^0!}{(N_i^0+\nu_{i}\xi)!}
	\label{eq:Pacc}
	\biggr),
\end{equation}
where $\Delta U=U_o-U_n$ is the interaction energy change,
$\beta=1/k_\mathrm{B}T$, $V$ is the simulation box volume, $\bar\nu = \sum_i
\nu_i$. The extent of reaction, $\xi=1$ for the forward, and $\xi=-1$ for the
reverse direction.
The parameter $\Gamma$ is related to $K$ as
\begin{equation}
	\Gamma = K \biggl(\frac{p^{\ominus}}{N_{\mathrm{A}}k_\mathrm{B}T}\biggr)^{\bar\nu},
	  \label{eq:Gamma}
\end{equation}
where $N_{\mathrm{A}}$ is the Avogadro number and 
$p^{\ominus}=1\unit{atm}$ is the standard pressure.
It is often convenient and in some cases even necessary (dissociation reaction
of polyelectrolytes) that some particles representing reactants are not removed
from the system, but their identity is changed to that of the products (and
vice versa in the reverse direction).

\begin{essyntax}
  \variant{1} reaction\_ensemble

  \variant{2} reaction\_ensemble add equilibrium_constant \var{K} educt\_types \var{list\_educt\_types} educt_coefficients \var{list\_educt\_coefficients} product\_types \var{list\_product\_types} product\_coefficients \var{list\_product\_coefficients}
  
  \variant{3a} reaction\_ensemble standard\_pressure\_in\_simulation\_units 
  \var{standard\_pressure} % It should be the standard pressure that was used to obtain the value of K
  % In principle, one could use arbitrary standard pressures, but 1atm = 101325Pa is almost exclusively used
  %\var{desired\_pressure\_at\_which\_reactions\_occur} % PK: this was wrong and confusing
  \variant{3b} reaction\_ensemble temperature\_reaction\_ensemble \var{temperature\_reaction\_ensemble}
  \variant{3c} reaction\_ensemble exclusion\_radius \var{exclusion\_radius}
  \variant{5} reaction\_ensemble set\_default\_charge\_of\_type \var{type} \var{charge}
  \variant{6} reaction\_ensemble cylindrical\_constraint\_in\_z\_direction center \var{cyl_x} \var{cyl_y} radius \var{radius}
  \variant{7} reaction\_ensemble wall\_constraints\_in\_z\_direction \var{slab\_z\_start} \var{slab\_z\_end}
  \variant{8} reaction\_ensemble volume \var{volume}
  \variant{9} reaction\_ensemble do
            
  Required features: REACTION\_ENSEMBLE

  Note: the TCL commands should be used in the above order. 
  The implementation in the tcl interface is sensitive to the order of the arguments of the \verb!reaction_ensemble! command. 

  \end{essyntax}


Here we describe just differences between the behaviour of the TCL interface and python.
Please refer to python syntax description for a more detailed explanation of the correspondning
variants.

\variant{1} print current reaction system, including and checks for some essential parameters.

\variant{2a} \variant{2b} \variant{2c} set the standard pressure, temperature and exclusion radius. These are necessary
parameters to run a reaction ensemble simulation.
\variant{2a} \variant{2b} and \variant{2c} are implemented as a single command \variant{2} in python implementation.
Setting temperature and pressure using \variant{3a} and \variant{3b} is required for running the simulation.

\variant{3} in the TCL implementation it is necessary to provide the reverse direction as a separate reaction with reaction constant $1/K$. The python implementation sets up the reverse direction automatically. Educt in German refers to a compound entering a reaction while in English
it has a different meaning

\variant{4} in the TCL it has to be called separately for each type that occurs in the reaction.

\variant{5} restrict the sampling volume to a cylinder in the $z$-direction. 
Requires setting the volume by \variant{7}

\variant{6} restrict the sampling volume to a slab in the $z$-direction.
Requires setting the volume by \variant{7}

\variant{7} set the volume to be used in the acceptance probability,
Eq.\ref{eq:Pacc}. This is necessary when unsing constraints \variant{5} or
\variant{6}. If not set, box volume is used by default.

\variant{8} perform one randomly selected reaction of the provided reaction system.

  \begin{arguments}
  \item[\var{K}] dimensionless (thermodynamic) equilibrium constant of the reaction, see Eq.\ref{Keq}. 
	  %Note that this is not necessarily the same number as equilibrium constant from the law of mass action, but needs to be converted to the dimensionless equilibrium constant $K=\exp(-\beta \Delta G)$).
\item[\var{list\_reactant\_types}] a list of types of reactants in the reaction.
\item[\var{list\_reactant\_coefficients}] a list of stoichiometric coefficients of the reactants 
	in the same order as the list of their types
\item[\var{list\_product\_types}] a list of product types of the reaction.
\item[\var{list\_product\_coefficients}] a list of stoichiometric coefficients of products of the reaction
	in the same order as the list of their types
\item[\var{desired\_pressure\_at\_which\_reactions\_occur}] the pressure in simulation units where the reactions should occur. This is an input parameter of the reaction ensemble.
\item[\var{type}] a type id.
\item[\var{charge}] a charge that corresponds to the previously given \var{type}. Make sure to provide this for all types that occur in a reaction!
  \end{arguments}
  
  \begin{pysyntax}
  	from espressomd import reaction_ensemble \\
  	\variant{1}  RE=reaction_ensemble.ReactionEnsemble(standard_pressure=float, temperature=float, exclusion_radius=float) \\
  	\variant{2}  RE.print_status() \\
  	\variant{3}  RE.add(equilibrium_constant=equilibrium constant,reactant_types=list,reactant_coefficients=list, product_types=list, product_coefficients=list) \\
  	\variant{4}  RE.default_charges(dictionary=\{type1,charge1; type2, charge2;...\}) \\
  	\variant{5}  RE.set_cylindrical_constraint_in_z_direction(center_x, center_y, radius_of_cylinder) \\
  	\variant{6}  RE.set_wall_constraints_in_z_direction(slab_start_z,slab_end_z) \\
	\variant{7}  RE.set_volume(volume) \\
	\variant{8}  RE.reaction() \\
	\variant{9}  RE.do_global_mc_move_for_one_particle_of_type(type) (similar like in the Wang-Landau case below) \\
	\variant{10} RE.print_acceptance_rate_configurational_moves() (similar like in the Wang-Landau case below) \\
	\variant{11} RE.free() 
	\begin{features}
		\required{REACTION_ENSEMBLE}
	\end{features}
\end{pysyntax}
  
\variant{1} initialize the reaction ensemble by setting the standard pressure, temperature, and the exclusion radius.\\
Exclusion radius is the minimal distance that a new
particle must have towards another particle when the new particle is inserted.
This is valid if there is some repulsive potential in the system, that brings
the energy to (approximately) infinity if particles are too close and therefore
$\exp(-\beta E)$ gives these configurations aproximately zero contribution in
the partition function. The exclusion radius needs to be set in order to avoid oppositley charged particles to be set too close to each other or in order to avoid too steep gradients from the short ranged interaction potential when using the Reaction ensemble together with a MD scheme.

\variant{2} prints the current reaction system and checks for some essential parameters.

\variant{3} sets up a reaction in one particular direction. Unlik the TCL
implementation, the python implementation sets up the reverse direction
automatically.

\variant{4} sets the charges of the particle types that are created. Note that
it has to be called for each type that occurs in the reaction system
individually.

\variant{5} constrain the reaction moves within a cylinder defined by its axis passing through centres ($x$ and $y$) and the radius. 
Requires setting the volume using \variant{6}.

\variant{6} restrict the sampling area to a slab in z-direction, similar to \variant{5}.
Requires setting the volume using \variant{6}.

\variant{7} set the volume to be used in the acceptance probability,
Eq.\ref{eq:Pacc}. This can be useful when unsing constraints \variant{5} or
\variant{6}, if the relevant volume is different from the box volume. If not
set, box volume is used by default.

\variant{8} performs one randomly selected reaction of the provided reaction system.
	\variant{9}  RE.do_global_mc_move_for_one_particle_of_type(type) (similar like in the Wang-Landau case below) \\
	\variant{10} RE.print_acceptance_rate_configurational_moves() (similar like in the Wang-Landau case below) \\
	\variant{11} RE.free() 

  \begin{arguments}
  \item[\var{K}] dimensionless (thermodynamic) equilibrium constant of the reaction, see Eq.\ref{Keq}. 
	  %Note that this is not necessarily the same number as equilibrium constant from the law of mass action, but needs to be converted to the dimensionless equilibrium constant $K=\exp(-\beta \Delta G)$).
\item[\var{list\_reactant\_types}] a list of types of reactants in the reaction.
\item[\var{list\_reactant\_coefficients}] a list of stoichiometric coefficients of the reactants 
	in the same order as the list of their types
\item[\var{list\_product\_types}] a list of product types of the reaction.
\item[\var{list\_product\_coefficients}] a list of stoichiometric coefficients of products of the reaction
	in the same order as the list of their types
\item[\var{desired\_pressure\_at\_which\_reactions\_occur}] the pressure in simulation units where the reactions should occur. This is an input parameter of the reaction ensemble.
\item[\var{type}] a type id.
\item[\var{charge}] a charge that corresponds to the previously given \var{type}. Make sure to provide this for all types that occur in a reaction!
  \end{arguments}


\subsection{Wang-Landau Reaction Ensemble}
  Since you might be interested in thermodynamic properties of a reacting system you may use the Wang-Landau algorithm\cite{wang01a} to obtain them. Here the 1/t Wang-Landau algorithm\cite{belardinelli07a} is implemented since it does not suffer from systematic errors.
  Additionally to the above commands for the reaction ensemble use the following commands for the Wang-Landau reaction ensemble:
  \begin{essyntax}
  \variant{11} reaction\_ensemble wang_landau add degree\_of\_association associated\_type \var{associated\_type} min \var{min\_value} max \var{max\_value} corresponding\_acid\_types \var{list\_of\_corresponding\_types}
  \variant{12} reaction\_ensemble wang\_landau add energy filename \var{energy\_boundary\_filename} delta \var{Delta\_E}
  \variant{13} reaction\_ensemble wang\_landau counter\_ion\_type \var{counter\_ion\_type} [polymer\_start\_id \var{polymer\_start\_id}] [polymer\_end\_id \var{polymer\_start\_id}] [fix_polymer_monomers] 
  \variant{14} reaction\_ensemble wang\_landau final\_wang\_landau\_parameter \var{final\_wang\_landau\_parameter}
  \variant{15} reaction\_ensemble wang\_landau full\_path\_to\_output\_filename \var{full\_path\_to\_output\_filename}
  \variant{16} reaction\_ensemble wang\_landau do\_not\_sample\_reaction\_partition\_function
  \variant{17} reaction\_ensemble wang\_landau update\_maximum\_and\_minimum\_energies\_at\_current\_state
  \variant{18} reaction\_ensemble wang\_landau write\_out\_preliminary\_energy\_run\_results \var{energy\_boundary\_filename}
  \variant{19} reaction_ensemble wang_landau \var{wang\_landau\_setps}
    \variant{20} reaction\_ensemble wang\_landau use\_hybrid\_monte\_carlo (should require feature CONSTRAINTS)
  \variant{21} reaction\_ensemble wang\_landau do
  \variant{22} reaction\_ensemble [wang\_landau] monte\_carlo\_move\_for\_type \var{type}
  \variant{23} reaction\_ensemble wang\_landau write\_wang\_landau\_checkpoint \var{unique identifier}
  \variant{24} reaction\_ensemble wang\_landau load\_wang\_landau\_checkpoint \var{unique identifier}
  \variant{25} reaction\_ensemble print\_acceptance\_rate
  
  Required features: REACTION\_ENSEMBLE
\end{essyntax}

  \begin{pysyntax}
  	from espressomd import reaction_ensemble \\
  	RE=reaction_ensemble.ReactionEnsemble(standard_pressure=float, temperature=float, exclusion_radius=float) \\
	\variant{11} RE.add_collective_variable_degree_of_association(associated_type=int, min=float, max=float, corresponding_acid_types=list) \\
	\variant{12} RE.add_collective_variable_potential_energy(filename=string,delta=float) \\
	\variant{13} RE.counter_ion_type=int \\
	\variant{13} RE.polymer_start_id=int \\
	\variant{13} RE.polymer_end_id=int \\
	\variant{13} RE.fix_polymer_monomers=bool \\
	\variant{14} \variant{15} \variant{16} \variant{19} \variant{20} RE.set_wang_landau_parameters(final_wang_landau_parameter=float, wang_landau_steps=float, full_path_to_output_filename=string, do_not_sample_reaction_partition_function=bool, use_hybrid_monte_carlo=bool) \\
	\variant{17} RE.update_maximum_and_minimum_energies_at_current_state() \\
	\variant{18} RE.write_out_preliminary_energy_run_results() \\
	\variant{21} RE.do_reaction_wang_landau() \\
	\variant{22} RE.do_global_mc_move_for_one_particle_of_type_wang_landau(type) \\
	\variant{23} RE.write_wang_landau_checkpoint() \\
	\variant{24} RE.load_wang_landau_checkpoint() \\
	\variant{25} RE.print_acceptance_rate_configurational_moves() \\
	\variant{26} RE.wang_landau_free()
	\begin{features}
		\required{REACTION_ENSEMBLE}
	\end{features}
\end{pysyntax}

\variant{11} adds a reaction coordinate of the type degree of association

\variant{12} adds a reaction coordinate of the type potential energy. In the case of an potential energy reaction coordinate the acceptance probabilities do not contain the factor $\exp(-\beta \Delta E_\text{pot})$. Note since
also configuration changing moves have to be biased by the Wang-Landau
potential in the case of energy reweighting the configuration changing
Monte-Carlo moves are implemented which take care of the biasing. 

\variant{13} provides the counter\_ion\_type that gets moved by MC moves as
well as optionally the ids of the monomers that correspond to a polymer that
should be moved. In the case of no energy collective variable you may
additionally (or instead) use MD to change configurations in your simulation.
In the case of no energy collective variable \variant{13} is therefore
optional. In the case of using an energy collective variable \variant{13}
together with \var{counter\_ion\_type} has to be used. Also in this case
\var{polymer\_start\_id} and \var{polymer\_start\_id} are optional, since you
might not want to change the configuration of your polymer, e.g. if you are
trying to simulate a rigid conformation.

\variant{14} sets the final Wang-Landau parameter

\variant{15} sets the path to the output file of the Wang-Landau algorithm which contains the Wang-Landau potential

\variant{16} avoids sampling the Reaction ensemble partition function in the Wang-Landau algorithm. Therefore this option makes all degrees of association equally probable. This option may be used in the sweeping mode of the reaction ensemble, since the reaction ensemble partition function can be later added analytically.

\variant{17} records the minimum and maximum potential energy as a function of the degree of association in a preliminary Wang-Landau reaction ensemble simulation where the acceptance probability includes the factor $\exp(-\beta \Delta E_\text{pot})$. The minimal and maximal potential energys which occur in the system are needed for the energy reweighting simulations wehere the factor $\exp(-\beta \Delta E_\text{pot})$ is not included in the acceptance probability in order to avoid choosing the wrong potential energy boundaries.

\variant{18} this writes out the minimum and maximum potential energy as a function of the degree of association to a file. It requires that previously \variant{17} was used.

\variant{19} this sets the number of Wang-Landau steps which are performed at once. Do not use too many Wang-Landau steps consequetively without having conformation changing steps in between.


\variant{20}, is an experimental implementation only and per default it is turned off! Check the implementation again before using HMC here. Make sure not to use an MD thermostat in the case of using the Wang-Landau algorithm with Hybrid-Monte-Carlo moves. Wang-Landau moves with the Hybrid-Monte-Carlo moves are interesting for polymer systems since they avoid trapping in the energy reweighting case. However it is stressed here again that the implementation is experimental only. Sets whether the conformation changing Monte-Carlo moves should use a hybrid Monte Carlo scheme (use MD to propose new configurations and accept these proposed configurations with a probability proportional to $\exp(-\beta \Delta E_\text{pot})$).

\variant{21} performs a reaction in the Wang-Landau reaction ensemble.
\variant{22} performs a global monte carlo move for one paricles of the given type. If there are multiple types, that need to be moved, make sure to move them in a random order to avoid artefacts. Can be used without Wang-Landau biasing when you ommit the
optional wang-landau keyword. For these monte carlo moves we need to provide
additional information which are put into espresso by \variant{13}. 
\variant{23, 24} can be used to checkpoint the Wang-Landau histogram, potential, parameter and the number of executed trial moves.
\variant{25} returns the acceptrance rate for all MC moves that are preformed with reaction\_ensemble monte\_carlo\_move\_for\_type
\variant{26} frees the Wang-Landau data structures in the core.

\begin{arguments}
\item[\var{associated\_type}] type id of the associated type when calculating the degree of association
\item[\var{min\_value}] the minimum value of the range of the degree of association which should be sampled
\item[\var{max\_value}] the maximum value of the range of the degree of association which should be sampled
\item[\var{list\_of\_corresponding\_types}] 
\item[\var{energy\_boundary\_filename}] filename of file that contains the energy boundaries. This file has to be obtained before being able to run a simulation with the energy as collective variable.
\item[\var{Delta\_E}] discretization distance of the energy when binning it in the process of using it as a collective variable. Avoid the begin and the end of the CV\_interval not being a multiple of the delta\_CV.
\item[\var{final\_wang\_landau\_parameter}] Wang-Landau parameter at which the simulation should stop.
\item[\var{full\_path\_to\_output\_filename}] Filename of the file that contains the Wang-Landau potential.
\item[\var{wang\_landau\_setps}], number of Wang-Landau steps performed at once. This is for performance. It reduces the need for the tcl interpreter to be called.
\item[\var{counter\_ion\_type}], type of ions which will be moved by global Monte-Carlo moves. \textit{Since you cannot employ MD when using the potential energy collective variable} without adding a force (not implemented) that is calculated from the Wang-Landau potential we use MC moves to explore new configurations. In the case of not using the energy collective variable you may use MD steps to propagate your system instead of using MC moves.
\item[\var{polymer\_start\_id}] the start id of the polymer, optional. Should be set when you have a non fixed polymer and want it to be moved by MC trail moves in order to sample its configuration space.
\item[\var{polymer\_end\_id}] the end id of the polymer, optional. Should be set when you have a non fixed polymer and want it to be moved by MC trail moves in order to sample its configuration space.
\item[fix\_polymer\_monomers] fixes the polymer monomers in the Monte Carlo moves
\end{arguments}

\subsection{Constant pH method}
OUTDATED, Please remove as soon as possible. Do not modify. Only work with the sphinx documentation.
In the constant pH method due to Reed and Reed \cite{reed92a} 
it is possible to set the chemical potential of $H^{+}$ ions, assuming
the simulated system is coupled to an infinite reservoir.
This value is the used to simulate dissociation equilibrium of acids and bases.
Under certain conditions, the constant pH method can yield equivalent
results as the reaction ensemble. For more information see ~\cite{landsgesell2016b}. 
However, it treats the chemical potential of $H^{+}$ ions and their
actual number in the simulation box as independent 
variables, which can lead to serious artifacts.
The constant pH method significantly differs in its derivation compared to the Reaction Ensemble.
%Whereas the pH in the reaction ensemble adjusts \textit{in the simulation box}
%(this means that is assured that there is a certain number of protons in the
%simulation box) the constant pH method couples the simulation box to a kind of implicit
%proton bath in the way reactions are performed. 
The constant pH method can be used by initializing the reactions of interest with the commands
mentioned for the reaction ensemble. However with the difference that you do
not provide the dimensionless reaction constant but directly the
\textit{apparent reaction constant} (from the law of mass action) $K_a$ which
can in general carry a unit. For an example file for how to setup a Constant pH simulation, see a file in the testcases. The following commands for the constant pH method are available:
\begin{essyntax}
	\variant{1} reaction_ensemble constant_pH pH \var{pH}
	\variant{2} reaction_ensemble constant_pH do
	
	Required features: REACTION_ENSEMBLE
\end{essyntax}

  \begin{pysyntax}
  	from espressomd import reaction_ensemble \\
  	RE=reaction_ensemble.ReactionEnsemble(standard_pressure=ignored_float, temperature=float, exclusion_radius=float) \\
  	RE.add(equilibrium_constant=equilibrium constant,reactant_types=list,reactant_coefficients=list, product_types=list, product_coefficients=list) \\
  	RE.default_charges(dictionary=\{type1,charge1; type2, charge2;...\}) \\
	RE.print_status() \\
	\variant{1} RE.set_pH_core(pH_input) \\
	\variant{2} RE.do_reaction_constant_pH() 
	\begin{features}
		\required{REACTION_ENSEMBLE}
	\end{features}
\end{pysyntax}


\variant{1} sets the pH that the pH bath assumes and \variant{2} performs a reaction according to the constant pH method.


\section{Grand Canonical Ensemble}
OUTDATED, Please remove as soon as possible. Do not modify. Only work with the sphinx documentation.
Since the Reaction Ensemble acceptance transition probability can be derived from the grand canonical acceptance transition probability we can use the reaction ensemble to implement grand canonical simulation moves. This is done via adding reactions that only have reactants (for the deletion of particles) or only have products (for the creation of particles). There exists a one to one mapping of the expressions in the grand canonical transition probabilities and the expressions in the reaction ensemble transition probabilities.
\subsection{How to add the water autodissociation to a simulation}
With the above trick of grand canonical simulation moves include we can include the autodissociation of water into the system.
In order to add the water autodissociation \schemestart 2 H$_2$O \arrow{<=>} H$_3$O$^+$ +OH$^-$ \schemestop  to a simulation, add the following ex nihilo reactions to Espresso. ($\emptyset$, read ex nihilo). Ex nihilo means that the reaction has no reactants or products. Therefore, if $\emptyset$ is a product, particles vanish and if $\emptyset$ is an reactant, then particles are created ex nihilo:
\begin{itemize}
\item \ce{$\emptyset$ -> H3O+ + OH-} with reaction constant $K$
\item \ce{ H3O+ + OH- -> $\emptyset$ } with reaction constant $1/K$,
\end{itemize}
where K is given implicitly as a function of the apparent dissociation constant $K_w=10^{-14} \mathrm{mol^2/l^2}=x\cdot \mathrm{1/(\sigma^3)^2}$: $K=(x\cdot \mathrm{1/(\sigma^3)^2})/(\beta P^0)^{\overline{\nu}}$ with $\overline{\nu}=2$ for the dissociation reaction and where x is the value of the apparent dissociation constant that is converted from $\mathrm{mol^2/l^2}$ to a number density in $1/(\sigma^3)^2$, where $\sigma$ is the simulation length unit. If $\beta$ and $P^0$ are provided in simulation units this will make $K$ dimensionless. 
As a test for the autodissociation of water a big simulation box can be set up and the autodissociation reaction can be performed. Then the box should fill with the correct number of protons and hydroxide ions (check for the number of protons and hydroxide ions in the given simulation volume and compare this to the expected value at pH 7). Further the $pK_w=14$ should be reproduced -also in the case of an initial excess of acid or base in the simulation box. Note that this only works for big enough volumes.
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "ug"
%%% End: 
