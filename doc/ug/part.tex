% Copyright (C) 2010,2011,2012,2013,2014,2015,2016 The ESPResSo project
% Copyright (C) 2002,2003,2004,2005,2006,2007,2008,2009,2010 
%   Max-Planck-Institute for Polymer Research, Theory Group
%  
% This file is part of ESPResSo.
%   
% ESPResSo is free software: you can redistribute it and/or modify it
% under the terms of the GNU General Public License as published by the
% Free Software Foundation, either version 3 of the License, or (at your
% option) any later version.
%  
% ESPResSo is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.
%  
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
\chapter{Setting up particles}
\label{chap:part}

\section{\keyword{part}: Creating single particles}
\newescommand{part}

\subsection{Defining particle properties}
\label{ssec:particleproperties}

\begin{pysyntax}
  \property{
    espressomd.System()
  }{
    part[\arg{pid}]
  }{
    type=\arg{int},
    pos=\arg{array of 3 floats},
    v=\arg{array of 3 floats},
    f=\arg{array of 3 floats},
    bonds=\arg{bond},
    mass=\arg{float},
    omega_lab=\arg{array of 3 floats},
    rinertia=\arg{array of 3 floats},
    omega_body=\arg{array of 3 floats},
    torque_lab=\arg{array of 3 floats},
    quat=\arg{array of 4 floats},
    %director=\arg{},
    q=\arg{float},
    virtual=\arg{int $\geq$ 0},
    vs_relative=\arg{tuple of int and float},
    vs_auto_relate_to=\arg{int},
    dip=\arg{array of 3 floats},
    dipm=\arg{float},
    fix=\arg{array of 3 ints},
    ext_force=\arg{array of 3 floats},
    ext_torque=\arg{array of 3 floats},
    exclude=\arg{list of ints},
    temp=\arg{float},
    gamma=\arg{float},
    gamma_rot=\arg{float},
    rotation=\arg{bool},
    swimming=\arg{dictionary \ttfamily \{
      `f_swim':\arg{float},
      `v_swim':\arg{float},
      `mode':\arg{``pusher''|``puller''},
      `dipole_length':\arg{float},
      `rotational_friction':\arg{float}\}}
  }
\end{pysyntax}
\begin{essyntax}
  part
  \var{pid}
  \opt{pos \var{x} \var{y} \var{z}}
  \opt{type \var{typeid}}
  \opt{v \var{vx} \var{vy} \var{vz}}
  \opt{f \var{fx} \var{fy} \var{fz}}
  \opt{bond \var{bondid} \var{pid2} \dots}
  \require{1}{\opt{q \var{charge}}}
  \require{2}{\opt{quat \var{q1} \var{q2} \var{q3} \var{q4}}}
  \require{2}{\opt{omega_body/lab \var{x} \var{y} \var{z}}}
  \require{2}{\opt{torque_body/lab \var{x} \var{y} \var{z}}}
  \require{2}{\opt{rinertia \var{x} \var{y} \var{z}}}
  \require{3}{\opt{\opt{un}fix \var{x} \var{y} \var{z}}}
  \require{3}{\opt{ext_force \var{x} \var{y} \var{z}}}
  \require{2,3}{\opt{ext_torque \var{x} \var{y} \var{z}}}
  \require{4}{\opt{exclude \var{pid2}\dots}}
  \require{4}{\opt{exclude delete \var{pid2}\dots}}
  \require{5}{\opt{mass \var{mass}}}
  \require{6}{\opt{dipm \var{moment}}}
  \require{6}{\opt{dip \var{dx} \var{dy} \var{dz}}}
  \require{7,8}{\opt{virtual \var{v}}}
  \require{8}{\opt{vs\_relative \var{pid} \par{distance}}}
  \require{8}{\opt{vs\_auto\_relate\_to \var{pid}}}
  \require{9}{\opt{temp \var{T}}}
  \require{9}{\opt{gamma \var{g}}}
  \require{2,9}{\opt{gamma\_rot \var{grot}}}
  \require{10}{\opt{rotation \var{rot}}}
  \require{11}{\opt{solvation \var{lA} \var{kA} \var{lB} \var{kB}}}
  \require{12}{\opt{swimming \alt{\alt{v_swim \var{v\_swim} \asep
          f_swim \var{f\_swim}} \asep off}}}
  \requirelong{12,13}{%
    \optlong{swimming
      \alt{%
        \alt{v_swim \var{v\_swim} \asep f_swim \var{f\_swim}}
        \alt{pusher \asep puller}
        dipole_length \var{dipole\_length}
        rotational_friction \var{rotational\_friction}
      \asep off}%
    }%
  }
  \begin{features}
    \required[1]{ELECTROSTATICS} 
    \required[2]{ROTATION}
    \required[3]{EXTERNAL_FORCES}
    \required[4]{EXCLUSION}
    \required[5]{MASS}
    \required[6]{DIPOLES}
    \required[7]{VIRTUAL\_SITES\_COM}
    \required[8]{VIRTUAL\_SITES\_RELATIVE}
    \required[9]{LANGEVIN\_PER\_PARTICLE}
    \required[10]{ROTATION\_PER\_PARTICLE}
    \required[11]{SHANCHEN}
    \required[12]{ENGINE}
    \required[13]{LB \MakeLowercase{\textrm{or}} LB_GPU}
  \end{features}
\end{essyntax}

This command modifies particle data, namely position, type (monomer,
ion, \dots), charge, velocity, force and bonds. Multiple properties can
be changed at once. If you add a new particle the position has to be
set first because of the spatial decomposition.

\begin{arguments}
\item[\var{pid}]
\item[\opt{pos \var{x} \var{y} \var{z}}] Sets the position of this
  particle to $(x,y,z)$.
\item[\opt{type \var{typeid}}] Restrictions:
  $\var{typeid} \geq 0$.\\ The
  \var{typeid} is used in the \keyword{inter} command
  (see section \vref{tcl:inter}) to define the parameters of the non
  bonded interactions between different kinds of particles.
\item[\opt{v \var{vx} \var{vy} \var{vz}}] Sets the velocity of
  this particle to $(vx,vy,vz)$. The velocity remains variable and will be changed
  during integration.
\item[\opt{f \var{fx} \var{fy} \var{fz}}] Set the force acting on this particle
  to $(fx,fy,fz)$. The force remains variable and will be changed during integration. 
  However, whereas the velocity is modified with respect to the velocity you set
  upon integration, the force it recomputed during the integration step and any 
  force set in this way is lost during the integration step.
\item[\opt{bond \var{bondid} \var{pid2}\dots}]
  Restrictions: \var{bondid} $\geq 0$; \var{pid2} must
  be an existing particle.  The \var{bondid} is used for
  the inter command to define bonded interactions.
\item[bond delete] Will delete all bonds attached to this particle.
\item[\opt{q \var{charge}}] Sets the charge of this particle to $q$.
\item[\opt{quat \var{q1} \var{q2} \var{q3} \var{q4}}] Sets the
  quaternion representation of the rotational position of this
  particle.
\item[\opt{omega_body} \var{x} \var{y} \var{z} \alt \opt{omega_body}
  \var{x} \var{y} \var{z}] The command \opt{omega_body} sets the
  angular momentum of this particle in the particle's co-rotating
  frame (or body frame) and the command \opt{omega_lab} sets it for
  the particle in the fixed frame (or laboratory frame). If you set
  the angular momentum of the particle in the lab frame, the
  orientation of the particle (\opt{quat}) must be set before invoking
  \opt{omega_lab}, otherwise the conversion from lab to body frame
  will not be handled properly.
\item[\opt{torque_body/lab \var{x} \var{y} \var{z}}] The command
  \opt{torque_body} sets the torque of this particle in the particle's
  co-rotating frame (or body frame) and the command \opt{torque_lab}
  sets it for the particle in the fixed frame (or laboratory
  frame). If you set the torque of the particle in the lab frame, the
  orientation of the particle (\opt{quat}) must be set before invoking
  \opt{torque_lab}, otherwise the conversion from lab to body frame
  will not be handled properly.
\item[\opt{rinertia \var{x} \var{y} \var{z}}] Sets the diagonal
  elements of this particles rotational inertia tensor. These
  correspond with the inertial moments along the coordinate axes in
  the particle's co-rotating coordinate system. When the particle's
  quaternions are set to 1 0 0 0, the co-rotating and the fixed (lab)
  frame are co-aligned.
\item[\opt{fix \var{x} \var{y} \var{z}}] Fixes the particle in space.
  By supplying a set of 3 integers as arguments it is possible to fix
  motion in \var{x}, \var{y}, or \var{z} coordinates independently. For
  example \var{fix} 0 0 1 will fix motion only in z. Note that
  \var{fix} without arguments is equivalent to \var{fix} 1 1 1.
\item[\opt{unfix}] Release any external influence from the particle.
\item[\opt{ext_force \var{x} \var{y} \var{z}}]
  An additional external force is applied to the particle.
\item[\opt{ext_torque \var{x} \var{y} \var{z}}]
  An additional external torque is applied to the particle. This torque is specified
  in the laboratory frame!
\item[\opt{exclude \var{pid2}\dots+}] Restrictions:
  \var{pid2} must be an existing particle.  Between the
  current particle an the exclusion partner(s), no nonbonded
  interactions are calculated. Note that unlike bonds, exclusions are
  stored with both partners. Therefore this command adds the defined
  exclusions to both partners.
\item[\opt{exclude delete \var{pid2}\dots}] Searches for the
  given exclusion and deletes it. Again deletes the exclusion with
  both partners.
\item[\opt{mass \var{mass}}] Sets the mass of this particle to $mass$. If not
  set, all particles have a mass of 1 in reduced units.
\item[\opt{dipm \var{moment}}] Sets the dipol moment of this particle to $moment$.
\item[\opt{dip \var{dx} \var{dy} \var{dz}}] Sets the orientation of the
  dipole axis to $(dx,dy,dz)$.
\item[\opt{virtual \var{v}}] Declares the particles as virtual (1) or
  non-virtual (0, default). Please read chapter \ref{sec:virtual}
  before using virtual sites.
\item[\opt{vs\_auto\_relate\_to \var{pid}}] Automatically relates a
  virtual site to a non-virtual particle for the ``relative''
  implementation of virtual sites. \var{pid} is the id of the particle
  to which the virtual site should be related.
\item[\opt{vs\_relative \var{pid} \var{distance}}] Allows for manual
  access to the attributes of virtual sites in the ``relative''
  implementation. \var{pid} denotes the id of the particle to which
  this virtual site is related and \var{distance} the distance between
  non-virtual and virtual particle.
\item[\opt{temp \var{T}}] If used in combination with the Langevin
  thermostat (as documented in section \ref{sec:thermostat}), sets the
  temperature \var{T} individually for the particle with id
  \var{pid}. This allows to simulate systems containing particles of
  different temperatures. Caution: this has no influence on any other
  thermostat then the Langevin thermostat.
\item[\opt{gamma \var{g}}] If used in combination with the Langevin
  thermostat (as documented in section \ref{sec:thermostat}), sets the
  frictional coefficient \var{T} individually for the particle with id
  \var{pid}. This allows to simulate systems containing particles with
  different diffusion constants. Caution: this has no influence on any
  other thermostat then the Langevin thermostat.
\item[\opt{rotation \var{rot}}] Specifies whether a particle's
  rotational degrees of freedom along the different axes in the particle's body-fixed frame are integrated or not.
  If set to zero, rotation is disabled entirely, and the content of the torque and omega variables
  are meaningless. 
  Rotation of a particular axis is turned on by adding up the corresponding flags: x=2, y=4, z=8.
  To enable rotation around all axis, use a value of 2+4+8=14. This is also the default.
\item[\opt{solvation \var{lA} \var{kA} \var{lB} \var{kB}}] Sets the
  four solvation coupling constants for the two components of a
  Shan-Chen fluid, as documented in Section \ref{sec:scmd-coupling}.
\item[\opt{swimming \alt{\alt{v_swim \var{v\_swim} \asep f_swim
        \var{f\_swim}} \asep off}}] Enables the particle to be
  self-propelled in the direction determined by its quaternion. For
  setting the quaternion of the particle see \keyword{quat}. The
  self-propulsion speed will relax to a constant velocity, that is
  specified by \keyword{v_swim}. Alternatively it is possible to
  achieve a constant velocity by imposing a constant force term
  \keyword{f_swim} that is balanced by friction of a (Langevin)
  thermostat. The way the velocity of the particle decays to the
  constant terminal velocity in either of these methods is completely
  determined by the friction coefficient. You may only set one of the
  possibilities \keyword{v_swim} \emph{or} \keyword{f_swim} as you
  cannot relax to constant force \emph{and} constant velocity at the
  same time. The option \keyword{off} (re)sets \var{v\_swim} and
  \var{f\_swim} both to $0.0$ and thus disables swimming. This option
  applies to all non-lattice-Boltzmann thermostats. Note that there is
  no real difference between \keyword{v_swim} and \keyword{f_swim},
  since the latter may aways be chosen such that the same terminal
  velocity is achieved for a given friction coefficient.
\item[{\parbox[t]{\linewidth}{\optlong{swimming \alt{%
          \alt{v_swim \var{v\_swim} \asep f_swim \var{f\_swim}}
          \alt{pusher \asep puller} dipole_length \var{dipole\_length}
          rotational_friction \var{rotational\_friction} \asep off}%
      }}}] For an explanation of the parameters \keyword{v_swim},
  \keyword{f_swim} and \keyword{off} see the previous item. In
  lattice-Boltzmann self-propulsion is less trivial than for normal
  MD, because the self-propulsion is achieved by a force-free
  mechanism, which has strong implications for the far-field
  hydrodynamic flow field induced by the self-propelled particle. In
  \es{} only the dipolar component of the flow field of an active
  particle is taken into account. This flow field can be generated by
  a \emph{pushing} or a \emph{pulling} mechanism, leading to change in
  the sign of the dipolar flow field with respect to the direction of
  motion. You can specify the nature of the particle's flow field by
  using the keywords \keyword{pusher} or \keyword{puller}. You will
  also need to specify a \var{dipole\_length} which determines the
  distance of the source of propulsion from the particle's
  center. Note that you should not put this distance to zero; \es{}
  (currently) does not support mathematical dipole flow fields. The
  key \keyword{rotational_friction} can be used to set the friction
  that causes the orientation of the particle to change in shear
  flow. The torque on the particle is determined by taking the cross
  product of the difference between the fluid velocity at the center
  of the particle and at the source point and the vector connecting
  the center and source.

  \noindent
  You may ask: ``Why are there two methods \var{v\_swim} and
  \var{f\_swim} for the self-propulsion using the lattice-Bolzmann
  algorithm?'' The answer is straightforward. When a particle is
  accelerating, it has a monopolar flow-field contribution which
  vanishes when it reaches its terminal velocity (for which there will
  only be a dipolar flow field). The major difference between the
  above two methods is that with \var{v\_swim} the flow field
  \emph{only} has a monopolar moment and \emph{only} while the
  particle is accelerating. As soon as the particle reaches a constant
  speed (given by \var{v\_swim}) this monopolar moment is gone and the
  flow field is zero! In contrast, \var{f\_swim} always, i.e., while
  accelerating \emph{and} while swimming at constant force possesses a
  dipolar flow field.

  \noindent
  \fbox{\parbox{\linewidth-2\fboxsep-2\fboxrule}{%
      Please note that even though swimming is interoperable with the
      CPU version of LB it is only supported on \emph{one} Open MPI
      node, i.e.\ $\text{\keyword{n_nodes}} = 1$.%
    }}
\end{arguments}

\warning{The options \opt{omega}, \opt{torque}, and \opt{tbf} are
  deprecated and will be removed in some future version.}

\subsection{Getting particle properties}
\index{Lees-Edwards Boundaries}
\begin{essyntax}
  \variant{1}
  part \var{pid} print
  \optlong{\alt{id \asep pos \asep type \asep folded_position \asep 
      type \asep q \asep v \asep f \asep torque_body \asep torque_lab 
      \asep body_frame_velocity \asep fix \asep ext_force 
      \asep ext_torque \asep bond \asep exclusions 
      \mbox{connections \opt{\var{range}}} \asep swimming}}\dots
  \variant{2} part
\end{essyntax}

Variant \variant{1} will return a list of the specified properties of
particle \var{pid}, or all properties, if no keyword is
specified.  Variant \variant{2} will return a list of all properties
of all particles.

Note that there is a difference between the \keyword{*_body} and
\keyword{*_lab}.  The first prints the variable in the co-rotating
frame, whereas the second gives the variable in the stationary frame,
the body and laboratory frames, respectively. One would typically want
to output the variable in the laboratory frame, since it is the frame
of interest. However for some tests involving reading and writing the
variable it may be desireable to know it in the body frame as well. Be
careful with reading and writing, if you write in the lab frame, then
read in the lab frame. If you are setting the variable in the lab
frame, the orientation of the particle's \keyword{quat} must be set
before, otherwise the conversion from lab to body frame will not be
handled properly.  Also be careful about the order in which you write
and read in data from a blockfile, for instance if you output the
variable in both frames!

The \keyword{body_frame_velocity} command is a print-only command that
gives the velocity in the body frame, which can be useful for 
determining the translational diffusion tensor of an anisotropic 
particle via the velocity auto-correlation (Green-Kubo) method.

\minisec{Example}
\begin{code}
part 40 print id pos q bonds
\end{code}
will return a list like
\begin{tclcode}
40 8.849 1.8172 1.4677 1.0 {}
\end{tclcode}
This routine is primarily intended for effective use in Tcl scripts.

When the keyword \keyword{connection} is specified, it returns the
connectivity of the particle up to \var{range} (defaults to 1). For
particle 5 in a linear chain the result up to \var{range} = 3 would
look like:
\begin{tclcode}
{ { 4 } { 6 } } { { 4 3 } { 6 7 } } { {4 3 2 } { 6 7 8 } } 
\end{tclcode}
The function is useful when you want to create bonded interactions to
all other particles a certain particle is connected to. Note that this
output can not be used as input to the part command. Check results if
you use them in ring structures.

If none of the options is specified, it returns all properties of the
particle, if it exists, in the form
\begin{tclcode}
  0 pos 2.1 6.4 3.1 type 0 q -1.0 v 0.0 0.0 0.0 f 0.0 0.0 0.0
  bonds { {0 480} {0 368} ... } 
\end{tclcode}
which may be used as an input to this function later on. The first
integer is the particle number.

Variant \variant{2} returns the properties of all stored particles in
a tcl-list with the same format as specified above:
\begin{tclcode}
{0 pos 2.1 6.4 3.1 type 0 q -1.0 v 0.0 0.0 0.0 f 0.0 0.0 0.0
 bonds{{0 480}{0 368}...}} 
{1 pos 1.0 2.0 3.0 type 0 q 1.0 v 0.0 0.0 0.0 f 0.0 0.0 0.0
 bonds{{0 340}{0 83}...}} 
{2...{{...}...}}
{3...{{...}...}}
...
\end{tclcode}

When using \texttt{pos}, the particle position returned is {\bf
  unfolded}, for convenience in diffusion calculations etc.  Note that
therefore blockfiles will contain imaged positions, but un-imaged
velocities, which should not be interpreted together. However, that is
fine for restoring the simulation, since the particled data is loaded
the same way.

\subsection{Deleting  particles}
\label{tcl:part:delete}

\todo{What is the syntax of variant 3?}
\begin{essyntax}
  \variant{1} part \var{pid} delete
  \variant{2} part deleteall
\end{essyntax}

In variant \variant{1}, the particle \var{pid} is deleted
and all bonds referencing it.  Variant \variant{2} will delete all
particles currently present in the simulation. Variant \variant{3}
will delete all currently defined exclusions.

\subsection{Exclusions}

\begin{essyntax}
  \variant{1} part auto\_exclusions \opt{\var{range}}
  \variant{2} part delete\_exclusions
  \begin{features}
    \required{EXCLUSIONS} 
  \end{features}
\end{essyntax}


Variant \variant{1} will create exclusions for all particles pairs
connected by not more than \var{range} bonds (\var{range} defaults to
2). This is typically used in atomistic simulations, where nearest and
next nearest neighbour interactions along the chain have to be omitted
since they are included in the bonding potentials. For example, if the
system contains particles $0$ \dots $100$, where particle $n$ is
bonded to particle $n-1$ for $1 \leq n \leq 100$, then it will result
in the exclusions:
\begin{itemize}
  \item particle 1 does not interact with particles 2 and 3
  \item particle 2 does not interact with particles 1, 3 and 4
  \item particle 3 does not interact with particles 1, 2, 4 and 5
  \item ...
\end{itemize}

Variant \variant{2} deletes all exclusions currently present in the
system.

\section{Creating groups of particle}

\subsection{\texttt{polymer}: Setting up polymer chains}

\newescommand{polymer}
\begin{essyntax}
  polymer 
  \var{num\_polymers} \var{monomers\_per\_chain}
  \var{bond\_length}\\
  \opt{start \var{pid}} 
  \opt{pos \var{x} \var{y} \var{z}}
  \opt{mode \alt{RW \asep SAW \asep PSAW} 
    \opt{\var{shield} \opt{\var{try_\mathrm{max}}}}} 
  \require{1}{\opt{charge \var{q}}} 
  \require{1}{\opt{distance \var{d_\mathrm{charged}}}}
  \opt{types \var{typeid_\mathrm{neutral}}
    \opt{\var{typeid_\mathrm{charged}}}} 
  \opt{bond \var{bondid}} 
  \opt{angle \var{\phi} \opt{\var{\theta} \opt{\var{x} \var{y}
        \var{z}}}}
  \require{2}{\opt{constraints}}
  \begin{features}
    \required[1]{ELECTROSTATICS}
    \required[2]{CONSTRAINTS}
  \end{features}
\end{essyntax}

This command will create \var{num\_polymers} polymer or
polyelectrolyte chains with \var{monomers\_per\_chain} monomers per
chain. The length of the bond between two adjacent monomers will be
set up to be \var{bond\_length}.

\begin{arguments}
\item[\var{num\_polymers}] Sets the number of polymer chains.
\item[\var{monomers\_per\_chain}] Sets the number of monomers per
  chain.
\item[\var{bond\_length}] Sets the initial distance between two
  adjacent monomers. The distance during the course of the simulation
  depends on the applied potentials. For fixed bond length please
  refer to the Rattle Shake algorithm\cite{andersen83a}.  The algorithm
  is based on Verlet algorithm and satisfy internal constraints for
  molecular models with internal constrains, using Lagrange
  multipliers.
\item[\opt{start \var{pid}}] Sets the particle number of the
  start monomer to be used with the \keyword{part} command. This
  defaults to 0.

\item[\opt{pos \var{x} \var{y} \var{z}}] Sets the position of the
  first monomer in the chain to \var{x}, \var{y}, \var{z} (defaults to
  a randomly chosen value)
  
\item[\opt{mode \alt{RW  \asep  PSAW  \asep  SAW} \opt{\var{shield}
      \opt{\var{try_\mathrm{max}}}}}]
  Selects the setup mode:
  \begin{description}
  \item[\keyword{RW} (Random walk)] The monomers are
    randomly placed by a random walk with a steps size of
    \var{bond_length}.
  \item[\keyword{PSAW} (Pruned self-avoiding walk)] The position of a
    monomer is randomly chosen in a distance of \var{bond\_length} to
    the previous monomer. If the position is closer to another
    particle than \var{shield}, the attempt is repeated up to
    \var{try_\mathrm{max}} times. Note, that this is not a real
    self-avoiding random walk, as the particle distribution is not the
    same. If you want a real self-avoiding walk, use the \keyword{SAW}
    mode.  However, \keyword{PSAW} is several orders of magnitude
    faster than \keyword{SAW}, especially for long chains.
  \item[\keyword{SAW} (Self-avoiding random walk)] The positions of
    the monomers are chosen as in the plain random walk. However, if
    this results in a chain that has a monomer that is closer to
    another particle than \var{shield}, a new attempt of setting up
    the whole chain is done, up to \var{try_\mathrm{max}} times.
  \end{description}
  The default for the mode is \keyword{RW}, the default for the
  \var{shield} is $1.0$, and the default for \var{try_\mathrm{max}} is
  $30000$, which is usually enough for \keyword{PSAW}. Depending on
  the length of the chain, for the \keyword{SAW} mode,
  \var{try_\mathrm{max}} has to be increased by several orders of
  magnitude.
\item[\opt{charge \var{valency}}] Sets the valency of the charged
  monomers.  If the valency of the charged polymers \var{valency} is
  smaller than $10^{-10}$, the charge is assumed to be zero, and the
  types are set to $\var{typeid_\mathrm{charged}} =
  \var{typeid_\mathrm{neutral}}$. If charge is not set, it defaults to
  0.0.
\item[\opt{distance \var{d_\mathrm{charged}}}] Sets the stride
  between the indices of two charged monomers. This defaults defaults
  to 1, meaning that all monomers in the chain are charged.
\item[\opt{types \var{typeid_\mathrm{neutral}}
    \var{typeid_\mathrm{charged}}}] Sets the type ids of the neutral
    and charged monomer types to be used with the \keyword{part}
    command. If only \var{typeid_\mathrm{neutral}} is defined,
    \var{typeid_\mathrm{charged}} defaults to $1$. If the option is
    omitted, both monomer types default to $0$.
  \item[\opt{bond \var{bondid}}] Sets the type number of the bonded
    interaction to be set up between the monomers. This defaults to
    $0$.  Any bonded interaction, no matter how many bonding-partners
    needed, is stored with the second particle in this bond. See
    chapter \ref{sec:inter-bonded}.
  \item[\opt{angle \var{\phi} [\var{\theta} [\var{x} \var{y}
      \var{z}]]}] Allows for setting up helices or planar polymers:
    \var{\phi} and \var{theta} are the angles between adjacent bonds.
    \var{x}, \var{y} and \var{z} set the position of the second
    monomer of the first chain.
  \item[\opt{constraints}] If this option is specified, the particle setup-up
  tries to obey previously defined constraints (see section \vref{sec:constraint}).
\end{arguments}

\subsection{\texttt{counterions}: Setting up counterions}
\warning{This feature will not be ported to the python interface.}
\newescommand{counterions}
\begin{essyntax}
  counterions
  \var{N} 
  \opt{start \var{pid}} 
  \opt{mode \alt{SAW \asep RW} \opt{\var{shield} \opt{\var{try_\mathrm{max}} }}} 
  \require{1}{\opt{charge \var{val}}}
  \opt{type \var{typeid}}
  \begin{features}
    \required[1]{ELECTROSTATICS}
  \end{features}
\end{essyntax}
This command will create \var{N} counterions in the simulation box.
\begin{arguments}
\item[\opt{start \var{pid}}] Sets the particle id of the first
  counterion.  It defaults to the current number of particles, \ie
  counterions are placed after all previously defined particles.
\item[\opt{mode \alt{SAW \asep RW} \opt{\var{shield}
      \opt{\var{try_\mathrm{max}} }}}] Specifies the setup method to
  place the counterions. It defaults to \keyword{SAW}. See the
  \keyword{polymer} command for a detailed description.
\item[\opt{charge \var{val}}] Specifies the charge of the counterions.
  If not set, it defaults to $-1.0$.
\item[\opt{type \var{typeid}}] Specifies the particle type of the
  counterions. It defaults to $2$.
\end{arguments}

\smallskip
\subsection{\texttt{salt}: Setting up salt ions}
\warning{This feature will not be ported to the python interface.}
\newescommand{salt}
\begin{essyntax}
  salt 
  \var{N_+} \var{N_-} 
  \opt{start \var{pid}} 
  \opt{mode \alt{SAW \asep RW} \opt{\var{shield} \opt{\var{try_\mathrm{max}}}}}
  \require{1}{\opt{charges \var{val_+} \opt{\var{val_-}}}} 
  \opt{types \var{typeid_+} \opt{\var{typeid_-}}}
  \opt{rad \var{r}}
  \begin{features}
    \required[1]{ELECTROSTATICS}
  \end{features}
\end{essyntax}

Create \var{N_+} positively and \var{N_-} negatively charged salt ions
of charge \var{val_+} and \var{val_-} within the simulation box.
\begin{arguments}
\item[\opt{start \var{pid}}] Sets the particle id of the first
  (positively charged) salt ion. It defaults to the current number of
  particles.
\item[\opt{mode \alt{SAW \asep RW} \opt{\var{shield}
      \opt{\var{try_\mathrm{max}} }}}] Specifies the setup method to
  place the counterions. It defaults to \keyword{SAW}. See the
  \keyword{polymer} command for a detailed description.
\item[\opt{charge \var{val_+} \opt{\var{val_-}}}] Sets the charge of
  the positive salt ions to \var{val_+} and the one of the negatively
  charged salt ions to \var{val_-}. If not set, the values default to
  $1.0$ and $-1.0$, respectively.
\item[\opt{type \var{typeid_+} \opt{\var{typeid_-}}}] Specifies the
  particle type of the salt ions. It defaults to $3$ respectively $4$.
\item[\opt{rad \var{r}}] The salt ions are only placed in a
  sphere with radius \var{r} around the origin.
\end{arguments}


\subsection{\texttt{diamond}: Setting up diamond polymer networks}
\newescommand{diamond}

\begin{essyntax}
  diamond 
  \var{a} \var{bond\_length} \var{monomers\_per\_chain} 
  \opt{counterions \var{N_\mathrm{CI}}}\\ 
  \require{1}{\opt{charges \var{val_\mathrm{node}}
      \var{val_\mathrm{monomer}} \var{val_\mathrm{CI}}}}
  \require{1}{\opt{distance \var{d_\mathrm{charged}}}}
  \opt{nonet}
  \begin{features}
    \required[1]{ELECTROSTATICS}
  \end{features}
\end{essyntax}

 \begin{pycode}
	from espressomd import diamond 
\end{pycode}

\begin{pysyntax}
	diamond.Diamond(a=\arg{double},bond_length=\arg{double}, MPC=\arg{int}, [N_CI=\arg{int}, val_nodes=\arg{double}, val_cM=\arg{double}, val_CI=\arg{double}, cM_dist=\arg{int}, nonet] )
\end{pysyntax}

Creates a diamond-shaped polymer network with 8 tetra-functional nodes
connected by $2*8$ polymer chains of length \var{monomers\_per\_chain} (MPC) in 
a unit cell of length \var{a}. Chain monomers are placed at a mutual distance \var{bond\_length}
along the vector connecting network nodes.
The polymer is created starting from particle ID 0. Nodes are assigned type 0,
monomers (both charged and uncharged) are type 1 and counterions type 2.
For inter-particle bonds interaction $0$ is taken which must be a two-particle bond.

\begin{figure}[ht]
  \label{fig:diamond}
  \begin{center}
  \includegraphics[height=6cm]{figures/diamond}
  \caption{Diamond-like polymer network with \var{monomers\_per\_chain}=15.}
  \end{center}
\end{figure}

\begin{arguments}
\item[\var{a}] Determines the size of the of the unit cell.
\item[\var{bond\_length}] Specifies the bond length of the polymer
  chains connecting the 8 tetra-functional nodes.
\item[\var{monomers\_per\_chain}] (MPC) Sets the number of chain monomers
  between the functional nodes.
\item[\opt{counterions \var{N_\mathrm{CI}}}] Adds \var{N_\mathrm{CI}}
  counterions to the system.
\item[\opt{charges \var{val_\mathrm{node}} \var{val_\mathrm{monomer}}
    \var{val_\mathrm{CI}}}] Sets the charge of the nodes to
  \var{val_\mathrm{node}}, the charge of the connecting monomers to
  \var{val_\mathrm{monomer}} (val\_cM), and the charge of the counterions to
  \var{val_\mathrm{CI}}.
\item[\opt{distance \var{d_\mathrm{charged}}}] (cM\_dist) Specifies the distance
  between charged monomers along the interconnecting chains. If
  $\var{d_\mathrm{charged}} > 1$ the remaining chain monomers are
  uncharged.
  \item[\opt{nonet}] Do not create bonds between the chains.
\end{arguments}


\subsection{\texttt{icosaeder}: Setting up an icosaeder}
\newescommand{icosaeder}
\begin{essyntax}
  icosaeder 
  \var{a} \var{monomers\_per\_chain} 
  \opt{counterions \var{N_\mathrm{CI}}} 
  \require{1}{\opt{charges \var{val_\mathrm{monomers}} \var{val_\mathrm{CI}}}}
  \require{1}{\opt{distance \var{d_\mathrm{charged}}}}
  \begin{features}
    \required[1]{ELECTROSTATICS}
  \end{features}
\end{essyntax}

Creates a modified icosaeder to model a fullerene (or soccer ball).
The edges are modeled by polymer chains connected at the corners of
the icosaeder. For inter-particle bonds interaction $0$ is taken which
must be a two-particle bond. Two particle types are used for the
pentagons and the interconnecting links. For an example, see figure \ref{fig:fullerene}.

\begin{figure}[ht]
 \begin{center}
  \includegraphics[height=6cm]{figures/fullerene}
  \caption{Icosaeder with \var{monomers\_per\_chain}=15.}
  \label{fig:fullerene}
  \end{center}
\end{figure}

\begin{arguments}
\item[\var{a}] Length of the links. Defines the size of the icosaeder.
\item[\var{monomers\_per\_chain}] Specifies the number of chain monomers along one edge.
\item[\opt{counterions \var{N_\mathrm{CI}}}] Specifies the number of
  counterions to be placed into the system.
\item[\opt{charges \var{val_\mathrm{monomers}} \var{val_\mathrm{CI}}}]
  Set the charges of the monomers to \var{val_\mathrm{monomers}} and
  the charges of the counterions to \var{val_\mathrm{CI}}.
\item[\opt{distance \var{d_\mathrm{charged}}}] Specifies the distance
  between two charged monomer along the edge. If
  $\var{d_\mathrm{charged}} > 1$ the remaining monomers are uncharged.
\end{arguments}

\subsection{\texttt{crosslink}: Cross-linking polymers}
\newescommand{crosslink}
\begin{essyntax}
  crosslink 
  \var{num\_polymer} \var{monomers\_per\_chain} 
  \opt{start \var{pid}} 
  \opt{catch \var{r_\mathrm{catch}}}
  \opt{distLink \var{link\_dist}} 
  \opt{distChain \var{chain\_dist}} 
  \opt{FENE \var{bondid}} 
  \opt{trials \var{try_\mathrm{max}}} 
\end{essyntax}

Attempts to end-crosslink the current configuration of
\var{num\_polymer} equally long polymers with
\var{monomers\_per\_chain} monomers each, returning how many ends are
successfully connected.

\begin{arguments}
\item[\opt{start \var{pid}}] \var{pid} specifies the first monomer of
  the chains to be linked. It has to be specified if the polymers do
  not start at id 0.
\item[\opt{catch \var{r_catch}}] Set the radius around each monomer
  which is searched for possible new monomers to connect to.
  \var{r_\mathrm{catch}} defaults to $1.9$.
\item[\opt{distLink \var{link\_dist}}] The minimal distance of two
  interconnecting links. It defaults to $2$.
\item[\opt{distChain \var{chain\_dist}}] The minimal distance for an
  interconnection along the same chain. It defaults to $0$. If set to
  \var{monomers\_per\_chain}, no interchain connections are created.
\item[\opt{FENE \var{bondid}}] Sets the bond type for the connections
  to \var{bondid}.
\item[\opt{trials \var{try_\mathrm{max}}}] If not specified,
  \var{try_\mathrm{max}} defaults to $30000$.
\end{arguments}

\subsection{\texttt{copy\_particles}: copying a set of particles}
\newescommand[copy-particles]{copy\_particles}
\begin{essyntax}
  copy_particles
  \opt{set \var{id1} \var{id2} \dots \asep range \var{from} {to} \dots} 
  \opt{shift \var{s\_x} \var{s\_y} \var{s\_z}}
\end{essyntax}

Copy a group of particles including their bonds. Positions can be
\opt{shift}ed by an offset $(\var{s\_x}, \var{s\_y}, \var{s\_z})$,
otherwise the copied set is at exactly the same position as the
original set. The particles can be given as a combination of
\opt{list}s or \opt{range}s. The new particles obtain in any case
consecutive identities after the largest current identity. The mapping
of the particles is returned as a list of old-new pairs, which can be
conveniently read into an array:
\begin{tclcode}
array set newidentities [copy_particles ...]
puts "particle 42 is now at position $newidentities(42)"
\end{tclcode} %$

Bonds within the defined particle set are copied with translated identities,
but not bonds with particles outside the list. That is, if the
particle set corresponds to a molecule, intramolecular bonds are
preserved, but not intermolecular ones.

Examples of use:\\
\begin{tclcode}
  copy_particles set {1 2 3 4} shift 0.0 0.0 0.0
  copy_particles set {1 2} set {3 4}
  copy_particles range 1 4
\end{tclcode}
All these examples do the same---making exact copies of particles 1 through 4.

\noindent
\fbox{\parbox{\linewidth-2\fboxsep-2\fboxrule}{%
    Please note that \keyword{copy_particles} only works if only
    fundamental particle properties are used, such as \keyword{pos},
    \keyword{type}, etc.\ as the \keyword{copy_particles} procedure
    only possesses parsers for these.  Other properties, such as
    \keyword{quatu} cannot be parsed and will thus lead to an error.%
  }}

\section{\texttt{constraint}: Setting up constraints}\label{sec:constraint}
\newescommand{constraint}

\begin{essyntax}
  \variant{1} 
  constraint wall normal \var{n_x} \var{n_y} \var{n_z} 
  dist \var{d} type \var{id} \opt{penetrable \var{flag}} \opt{reflecting
  \var{flag}} \opt{only_positive \var{flag}} \opt{tunable_slip \var{flag}}
  
  \variant{2}
  constraint sphere center \var{c_x} \var{c_y} \var{c_z} 
  radius \var{rad} direction \var{direction} type \var{id} \opt{penetrable \var{flag}} \opt{reflecting \var{flag}}
  
  \variant{3}
  constraint cylinder center \var{c_x} \var{c_y} \var{c_z} 
  axis \var{n_x} \var{n_y} \var{n_z} 
  radius \var{rad} length \var{length} 
  direction \var{direction} 
  type \var{id}  \opt{penetrable \var{flag}} \opt{reflecting \var{flag}}
  
  \variant{4}
  constraint rhomboid corner \var{p_x} \var{p_y} \var{p_z} 
  a \var{a_x} \var{a_y} \var{a_z} 
  b \var{b_x} \var{b_y} \var{b_z} \\
  c \var{c_x} \var{c_y} \var{c_z} 
  direction \var{direction} 
  type \var{id}  \opt{penetrable \var{flag}} \opt{reflecting \var{flag}}
  
  \variant{5}
  constraint maze nsphere \var{n} 
  dim \var{d} sphrad \var{r_s} cylrad \var{r_c}
  type \var{id} \opt{penetrable \var{flag}}
  
  \variant{6}  
  constraint pore center \var{c_x} \var{c_y} \var{c_z} 
  axis \var{n_x} \var{n_y} \var{n_z} 
  radius \var{rad} \opt{outer_radius \var{rad_S}} 
  \opt{smoothing_radius \var{rad_S}} length \var{length} 
  type \var{id} 

  \variant{7}
  constraint stomatocyte center \var{x} \var{y} \var{z} orientation \var{ox} \var{oy} \var{oz}
  outer_radius \var{Ro} inner_radius \var{Ri} layer_width \var{w} direction \var{direction} 
  type \var{id} \opt{penetrable \var{flag}} \opt{reflecting \var{flag}}
  
  \variant{8}
  constraint slitpore
  pore_mouth \var{z} \
             channel_width \var{c} \
             pore_width \var{w} \
             pore_length \var{l} \
             upper_smoothing_radius \var{us} \
             lower_smoothing_radius \var{ls} 
  
  
  \require{1}{%
    \variant{9}
    constraint rod center \var{c_x} \var{c_y} 
    lambda \var{lambda}
  } 
  
  \require{1}{%
    \variant{10}
    constraint plate height \var{h}
    sigma \var{sigma} 
  }
  
  \require{2,3}{%
    \variant{11}
    constraint ext_magn_field \var{f_x} \var{f_y} \var{f_z} 
  }
  
  \variant{12} 
  constraint plane cell \var{x} \var{y} \var{z} 
  type \var{id}

  \variant{13}
  constraint mindist_position \var{x} \var{y} \var{z}

  \variant{14}
  constraint hollow_cone center \var{x} \var{y} \var{z} orientation \var{ox} \var{oy} \var{oz}
  outer_radius \var{Ro} inner_radius \var{Ri} width \var{w} opening_angle \var{alpha} direction \var{direction} 
  type \var{id} \opt{penetrable \var{flag}} \opt{reflecting \var{flag}}

  \variant{15}
  constraint spherocylinder center \var{c_x} \var{c_y} \var{c_z} 
  axis \var{n_x} \var{n_y} \var{n_z} 
  radius \var{rad} length \var{length} 
  direction \var{direction} 
  type \var{id}  \opt{penetrable \var{flag}} \opt{reflecting \var{flag}}

  \variant{16}
  constraint mindist_position \var{x} \var{y} \var{z} 

  \begin{features}
    \required{CONSTRAINTS}
    \required[1]{ELECTROSTATICS}
    \required[2]{ROTATION}
    \required[3]{DIPOLES}
  \end{features}
\end{essyntax}

The \codebox{constraint} command offers a variety of surfaces that can
be defined to interact with desired particles. Variants \variant{1} to
\variant{7} create interactions via a non-bonded interaction
potential, where the distance between the two particles is replaced by
the distance of the center of the particle to the surface. The
constraints are identified like a particle via its type for the
non-bonded interaction.  After a type is defined for each constraint
one has to define the interaction of all different particle types with
the constraint using the \codebox{inter} command. In variants
\variant{1} to \variant{7}, constraints are able to be penetrated if
\var{flag} is set to 1. Otherwise, when the penetrable option is
ignored or \var{flag} is set to 0, the constraint cannot be violated,
i.e. no particle can go through the constraint surface.  In variants
\variant{1} to \variant{4} and \variant{7} it is also possible to
specify a flag indicating if the constraints should be reflecting. The
flags can equal 1 or 2.  The flag 1 corresponds to a reflection
process where the normal component of the velocity is reflected and
the tangential component remains unchanged. If the flag is 2, also the
tangential component is turned around, so that a bounce back motion is
performed. The second variant is useful for boundaries of DPD.  The
reflection property is only activated if an interaction is defined
between a particular particle and the constraint! This will usually be
a lennard-jones interaction with $\epsilon=0$, but finite interaction
range.

In variant \variant{1} if the \codebox{only_positive} flag is set to
1, interactions are only calculated if the particle is on the side of
the wall in which the normal vector is pointing. This has only an
effect for penetrable walls. If the \codebox{tunable_slip} flag is set
to 1, then slip boundary interactions apply that are essential for
microchannel flows like the Plane Poiseuille or Plane Couette
Flow. You also need to use the tunable_slip interaction (see
\ref{sec:tunableSlip}) for this too work.

Variants \variant{9} and \variant{10} create interactions based on electrostatic
interactions. The corresponding force acts in direction of the normal vector of the
surface and applies to all charged particles.

Variant \variant{11} does not define a surface but is based on magnetic
dipolar interaction with an external magnetic field. It applies to all particles
with a dipole moment.

The resulting surface in variant \variant{1} is a plane defined by the
normal vector \var{n_x} \var{n_y} \var{n_z} and the distance
\var{d} from the origin (in the direction of the normal vector). The force acts in direction of the normal. 
Note that the \var{d} describes the distance from the origin in units
of the normal vector so that the product of $d$ and $n$ is a point on the
surface. Therefore negative distances are quite common!

The resulting surface in variant
\variant{2} is a sphere with center \var{c_x} \var{c_y} \var{c_z} and radius
\var{rad}. The \var{direction} determines the force direction, -1 or
\opt{inside} for inward and +1 or \opt{outside} for outward. 

The resulting surface
in variant \variant{3} is a cylinder with center \var{c_x} \var{c_y}
\var{c_z} and radius \var{rad}. The \var{length} parameter is \textbf{half} 
of the cylinder length. The \var{axis} is a
vector along the cylinder axis, which is normalized in the program.
The \var{direction} is defined the same way as for the spherical
constraint. 

The resulting surface in variant \variant{4} is a rhomboid, defined by one 
corner located at \var{p_x} \var{p_y} \var{p_z} and three adjacent edges, 
defined by the three vectors connecting the corner p with it's three neighboring
corners, a (\var{a_x} \var{a_y} \var{a_z}), b (\var{b_x} \var{b_y} \var{b_z}) 
and c (\var{c_x} \var{c_y} \var{c_z}).

The resulting surface in variant \variant{5} is \var{n}
spheres of radius \var{r_s} along each dimension, connected by
cylinders of radius \var{r_c}. The spheres have simple cubic
symmetry. The spheres are distributed evenly by dividing the
\var{box_l} by \var{n}.  Dimension of the maze can be controlled by
\var{d}: 0 for one dimensional, 1 for two dimensional and 2 for three
dimensional maze.

Variant \variant{6} sets up a cylindrical pore similar to variant
\variant{3} with a center \var{c_x} \var{c_y} \var{c_z} and radius
\var{rad}. The \var{length} parameter is \textbf{half} of the cylinder
length. The \var{axis} is a vector along the cylinder axis, which is
normalized in the program. Optionally the outer radius of the pore can
be specified. By default this is (numerical) infinity and thus results in 
an infinite wall with one pore. The argument \codebox{radius \var{rad}} can 
be replaced by the argument \codebox{ radii \var{rad1} \var{rad2}} to obtain a 
pore with a conical shape and corresponding opening radii. The first radius 
is in the direction opposite to the axis vector. The same applies for 
\codebox{outer_radius \var{orad}} which can be replaced  with 
\codebox{outer_radii \var{orad1} \var{orad2}}. Per default sharp edges are
replaced by circles of unit radius. The radius of this smoothing can be set
with the optional keyword \codebox{smoothing_radius}.


Variant \variant{7} creates a stomatocyte shaped boundary. This command
should be used with care. The position can be any point in the simulation
box, and the orientation of the (cylindrically symmetric) stomatocyte is
given by a vector, which points in the direction of the symmetry axis, it
does not need to be normalized. The parameters: outer_radius \var{Ro},
inner_radius \var{Ri}, and layer_width \var{w}, specify the shape of the
stomatocyte. Here inappropriate choices of these parameters can yield 
undersired results. The width is used as a scaling parameter. That is,
a stomatocyte given by \var{Ro}:\var{Ri}:\var{w} = 7:3:1 is half the size
of the stomatocyte given by 7:3:2. Not all choices of the parameters give
reasonable values for the shape of the stomatocyte, but the combination
7:3:1 is a good point to start from when trying to modify the shape. 

In variant \variant{8}, a slit-shaped pore in a T-orientation to a flat channel
is created. 
The geometry is depicted in Fig.~\ref{fig:slitpore}.
It translationally invariant in y direction.
The pore (lower vertical part) extends in z-direction, and the channel (upper
horizontal part). The pore mouth is defined as the z-coordinate, where the lower
plane of the channel and the slit pore intersect. It is always centered in the
x-direction. A corresponding \codebox{dielectric} command decorates the surface
with surface charges that can be calculated with the ICC$\star$ algorithm.
\begin{figure}[ht]
  \label{fig:slitpore}
  \begin{center}
  \includegraphics[height=6cm]{figures/slitpore.pdf}
  \caption{The slitpore created by the \codebox{constraint slitpore.}}
  \end{center}
\end{figure}

Variant \variant{8} specifies an electrostatic interaction between the
charged particles in the system to an infinitely long rod with a line
charge of \var{lambda} which is alinge along the z-axis and centered
at \var{c_x} and \var{c_y}.

Variant \variant{9} specifies the electrostatic interactinos between
the charged particles in the system and an inifinitely large plate in
the x-y-plane at height \var{h}. The plate carries a charge density of
\var{sigma}.
  
Variant \variant{10} specifies the dipolar coupling of particles with a
dipolar moment to an external field \var{f_x} \var{f_y} \var{f_z}.

Variant \variant{11} creates an infinite plane at a fixed position. For
non-initializing a direction of the constraint values of the positions
have to be negative. For the tunable-slip boundary interactions you
have to set \emph{two} constraints.

Variant \variant{14} creates a hollow-cone shaped boundary. The position can be any point in the simulation
box, and the orientation of the (cylindrically symmetric) cone is
given by a vector, which points in the direction of the symmetry axis, it
does not need to be normalized. The parameters: outer_radius \var{Ro},
inner_radius \var{Ri}, width \var{w}, and opening_angle \var{alpha}, specify the shape of the object. The inner radius gives the narrow end opening size, the outer radius the length of the shaft, and the width the layer width, i.e., the thickness of the cone. The opening_angle (between 0 and $\pi/2$) specifies the angle of the cone. 

Variant \variant{15} creates a spherocylinder, that is, a cylinder capped by a hemisphere on either side. The parameter length \var{length} specifies the length of the shaft, excluding the two hemispherical caps. 

Variant \variant{16} calculates the smallest distance to all non-penetrable
constraints, that can be repulsive (wall, cylinder, sphere, rhomboid, maze, pore, slitpore).
Negative distances mean that the position is ``within'' the area that
particles should not access. Helpful to find initial configurations.) 

\minisec{Example}
To create an infinite plane in $z$-direction at $z=20.0$ of type id 1,
use:
\begin{code}
  constraint plane cell -10 -10 20 type 1
\end{code}

\subsection{Deleting a constraint}
\begin{essyntax}
  constraint delete \opt{\var{num}} 
\end{essyntax}

This command will delete constraints. If \var{num} is specified only this
constraint will deleted, otherwise all constraints will be removed from the
system. 

\subsection{Getting the force on a constraint}
\begin{essyntax}
constraint force \var{n} 
\end{essyntax}
Returns the force acting on the \var{n}th constraint. Note, however, that this
are only forces due to interactions with particles, not with other constraints.
Also, these forces still do not mean that the constraints move, they are just
the negative of the sum of forces acting on all particles due to this constraint.
Similarly, the total energy does not containt constraint-constraint contributions.


\subsection{Getting the currently defined constraints}
\begin{essyntax}
constraint  \opt{\var{num}} 
\end{essyntax}
Prints out all constraint information. If \var{num} is specified only this
constraint is displayed, otherwise all constraints will be printed.

\subsection{\texttt{harmonic_well}: Creating a harmonic trap}
 \newescommand{harmonic-well}
 \begin{essyntax}
   harmonic_well \{ \var{x} \var{y} \var{z} \} \var{k}
  \begin{features}
    \required{CUDA}
  \end{features}
 \end{essyntax}

 Calculates a spring force for all particles, where the equilibrium position
 of the spring is at \var{x y z} and it's force constant is \var{k}. A more
 flexible trap can be constructed with constraints, but this one runs on the GPU.

\section{Virtual sites}
\label{sec:virtual}
\index{virtual sites|mainindex}

Virtual sites are particles, the positions and velocities of which are
not obtained by integrating an equation of motion.  Rather, their
coordinates are obtained from the position (and orientation) of one or
more other particles. In this way, rigid arrangements of particles can
be constructed and a particle can be placed in the center of mass of a
set of other particles.  Virtual sites can interact with other
particles in the system by means of interactions. Forces are added to
them according to their respective particle type. Before the next
integration step, the forces accumulated on a virtual site are
distributed back to those particles, from which the virtual site was
derived.

There are two distinct types of virtual sites, described in the
following.

\subsection{Virtual sites in the center of mass of a molecule}

To activate this implementation, enable the feature
\feature{VIRTUAL_SITES_COM} (sec. \ref{sec:myconfig}).  Virtual sites
are then placed in the center of mass of a set of particles (as
defined below). Their velocity will also be that of the center of
mass. Forces accumulating on the virtual sites are distributed back to
the particles which form the molecule.  To place a virtual site at the
center of a molecule, perform the following steps in that order
\begin{enumerate}
\item Create a particle of the desired type for each molecule. It
  should be placed at least roughly in the center of the molecule to
  make sure, it's on the same node as the other particles forming the
  molecule, in a simulation with more than one cpu.
\item Make it a virtual site using 
  \begin{essyntaxbox}
    part \var{pid} virtual 1
  \end{essyntaxbox}
\item Declare the list of molecules and the particles they consist of:
  \begin{essyntaxbox}
    analyze set \{\var{moltype} \var{list of particle ids} ...\} ...
  \end{essyntaxbox}
  The lists of particles in a molecule comprise the non-virtual
  particles as well as the virtual site. The id of this molecule is
  its index in this list. For example,
  \begin{code}
    analyze set \{0 1 2 3 4\} \{0 5 6 7 8\} \{1 9 10 11\}
  \end{code}
  declares three molecules, of which the first two consist of three
  particles and a virtual site each (particles 1--4 and 5--8,
  respectively). The third molecule has type 1 and consists of two
  particles and a virtual site. The virtual sites were determined
  before by setting the \var{virtual} flag. You can choose freely one
  out of each molecule, for example particles 1, 5, and 9.
\item Assign to all particles that belong to the same molecule the
  molecule's id
  \begin{essyntaxbox}
    part \var{pid} mol \var{molid}
  \end{essyntaxbox}
  The molid is the index of the particle in the above list, so you
  would assign \var{molid} 0 to particles 1-4, \var{molid} 1 to
  particles 5-8 and \var{molid} 2 to particles 9-11. Alternatively,
  you can call
  \begin{essyntaxbox}
    analyze set topo_part_sync
  \end{essyntaxbox}
  to set the \var{molid}s from the molecule declarations.
\item Update the position of all virtual particles (optional)
  \begin{essyntaxbox}
    integrate 0
  \end{essyntaxbox}
\end{enumerate}
Please note that the use of virtual sites requires that the particles are numbered consecutively. I.e., the particle ids should go from zero to $N-1$, where $N$ is the number of particles.

The type of the molecule you can choose freely, it is only used in
certain analysis functions, namely \texttt{energy_kinetic_mol},
\texttt{pressure_mol} and \texttt{dipmom_mol}, which compute kinetic
energy, pressure and dipole moment per molecule type, respectively.


\subsection{Rigid arrangements of particles}

The ``relative'' implementation of virtual sites allows for the
simulation of rigid arrangements of particles. It can be used, \eg,
for extended dipoles and raspberry-particles, but also for more
complex configurations.  Position and velocity of a virtual site are
obtained from the position and orientation of exactly one non-virtual
particle, which has to be placed in the center of mass of the rigid
body. Several virtual sites can be related to one and the same
non-virtual particle.  The position of the virtual site is given by
\begin{equation}
\vec{x_v} =\vec{x_n} +O_n (O_v \vec{E_z}) d,
\end{equation}
where $\vec{x_n}$ is the position of the non-virtual particle, $O_n$
is the orientation of the non-virtual particle, $O_v$ denotes the
orientation of the vector $\vec{x_v}-\vec{x_n}$ with respect to the
non-virtual particle's body fixed frame and $d$ the distance between
virtual and non-virtual particle.  In words: The virtual site is
placed at a fixed distance from the non-virtual particle. When the
non-virtual particle rotates, the virtual sites rotates on an orbit
around the non-virtual particle's center.

To use this implementation of virtual sites, activate the feature
\feature{VIRTUAL_SITES_RELATIVE} (see sec. \ref{sec:myconfig}).  To
set up a virtual site,
\begin{enumerate}
\item Place the particle to which the virtual site should be
  related. It needs to be in the center of mass of the rigid
  arrangement of particles you create. Let its particle id be n.
\item Place a particle at the desired relative position, make it
  virtual and relate it to the first particle
  \begin{essyntaxbox}
    part \var{v} pos \var{pos} virtual 1 vs_auto_relate \var{n}
  \end{essyntaxbox}
\item Repeat the previous step with more virtual sites, if desired.
\item To update the positions of all virtual sites, call
  \begin{essyntaxbox}
    integrate 0
  \end{essyntaxbox}
\end{enumerate}

Please note:
\begin{itemize}
\item The relative position of the virtual site is defined by its
  distance from the non-virtual particle, the id of the non-virtual
  particle and a quaternion which defines the vector from non-virtual
  particle to virtual site in the non-virtual particle's body-fixed
  frame. This information is saved in the virtual site's
  vs\_relative-attribute. Take care, not to overwrite these after using
  vs\_auto\_relate.
\item Virtual sites can not be placed relative to other virtual sites,
  as the order in which the positions of virtual sites are updated is
  not guaranteed. Always relate a virtual site to a non-virtual
  particle placed in the center of mass of the rigid arrangement of
  particles.
\item Don't forget to declare the particle virtual in addition to
  calling vs\_auto\_relate
\item In case you know the correct quaternions, you can also setup a
  virtual site using
  \begin{essyntaxbox}
    part \var{v} virtual 1 vs_relative \var{n} \var{d} \var{q}
  \end{essyntaxbox}
  where n is the id of the non-virtual particle, d is its distance
  from the virtual site, and q are the quaternions.
\item In a simulation on more than one CPU, the effective cell size
  needs to be larger than the largest distance between a non-virtual
  particle and its associated virtual sites. To this aim, you need to
  set the global variable \var{min\_global\_cut} to this largest
  distance. \es issues a warning when creating a virtual site with
  \lit{vs_auto_relate_to} and the cutoff is insufficient.
\item If the virtual sites represent actual particles carrying a mass,
  the inertia tensor of the non-virtual particle in the center of mass
  needs to be adapted.
\item The presence of rigid bodies constructed by means of virtual
  sites adds a contribution to the pressure and stress tensor.
\item The use of virtual sites requires that the particles are
  numbered consecutively, \ie, the particle ids should go from zero to
  $N-1$, where $N$ is the number of particles.
\end{itemize}

\subsection{Additional features}

The behaviour of virtual sites can be fine-tuned with the following
switches in \texttt{myconfig.hpp} (sec. \ref{sec:myconfig})
\begin{itemize}
\item \feature{VIRTUAL_SITES_NO_VELOCITY} specifies that the velocity
  of virtual sites is not computed
\item \feature{VIRTUAL_SITES_THERMOSTAT} specifies that the Langevin
  thermostat should also act on virtual sites
\item \feature{THERMOSTAT_IGNORE_NON_VIRTUAL} specifies that the
  thermostat does not act on non-virtual particles
\end{itemize}

\section{Grand canonical feature}
For using \es conveniently for simulations in the grand canonical ensemble, or
other purposes, when particles of certain types are created and deleted frequently.
Particle ids can be stored in lists for each individual type and so random ids of
particles of a certain type can be drawn. 

\begin{essyntax}
part gc
\alt{\var{type} \asep \alt{\alt{find \asep delete \asep
status \asep number} \var{type}}}
\end{essyntax}
\begin{pycode}
from espressomd import grand_canonical
grand_canonical.setup([_type])
grand_canonical.delete_particles(_type)
grand_canonical.find_particle(_type)
grand_canonical.number_of_particles(_type)
\end{pycode}

If you want \es to keep track of particle ids of a certain type you have to
initialize the method by calling 
\begin{essyntax}
	part gc \var{type}
\end{essyntax}
\begin{pycode}
grand_canonical.setup([_type])
\end{pycode}
After that \es will keep track of particle ids of that type. 
When using the keyword \texttt{find} and a particle type, the
command will return a randomly chosen particle id, for a particle of
the given type. 
The keyword \texttt{status} will return a list with all particles with the given
type, similarly giving \texttt{number} as argument will return the number of
particles which share the given type.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "ug"
%%% End: 
