Input / Output
==============

No generic checkpointing!
-------------------------

One of the most asked-for feature that seems to be missing in is
*checkpointing*, a simple way to tell to store and restore the current
state of the simulation, and to be able to write this state to or read
it from a file. This would be most useful to be able to restart a
simulation from a specific point in time.

Unfortunately, it is impossible to provide a simple command
(``checkpoint``), out of two reasons. The main reason is that has no way
to determine what information constitutes the actual state of the
simulation. On the one hand, scripts sometimes use Tcl-variables that
contain essential information about a simulation, the stored values of
an observable that was computed in previous time steps, counters, etc.
These would have to be contained in a checkpoint. However, not all
Tcl-variables are of interest. For example, Tcl has a number of
automatically set variables that contain information about the hostname,
the machine type, etc. These variables should most probably *not* be
included the simulation state. has no way to distinguish between these
variables. On the other hand, the core has a number of internal
variables, the particle coordinates. While most of these are probably
good candidates for being included into a checkpoint, this is not
necessarily so. For example, when you have particles in your system that
have fixed coordinates, should these be stored in a checkpoint, or not?
If the system contains mostly fixed particles and only very few moving
particles, this would increase the memory size of a checkpoint
needlessly. And what about the interactions in the system, or the bonds?
Should these be stored in a checkpoint, or are they generated by the
script?

Another problem with a generic checkpoint would be the control flow of
the script. In principle, the checkpoint would have to store where in
the script the checkpointing function was called to be able to return
there. All this is even further complicated by the fact that is running
in parallel.

Instead, in , the user has to specify what information needs to be saved
to a file to be able to restore the simulation state. The ``blockfile``
and ``writemd`` commands help you to do that. ``blockfile`` writes text
files. When floating point numbers are stored in such files (the
particle positions), there is only a limited precision. Therefore, it is
not possible to bitwise reproduce a simulation state using this
function. When you need bitwise reproducibility, you will have to use
the command , which stores positions, forces and velocities in binary
format. Note that there is no command to write other MD parameters like
time step or interactions in binary format. You should restore these
using exactly the same Tcl command that you used to create them.

Finally, there is one more complication: random forces are computed in
the order the particles are stored in memory. This order usually differs
after reading a blockfile back, since the particles are stored in
consecutive identity order. In memory, they are usually not in a
specific order. Therefore, you need to use ``sort_particles`` after
writing a blockfile that you want to use for checkpointing, so that the
particles are resorted to the same consecutive order. Note that this
does not change physics, just the order the random numbers are applied.

When using an LB fluid, you need to also write out the fluid nodes, see
the ``lbfluid`` command for further details.

(Almost) generic checkpointing in Python
----------------------------------------

Referring to the previous section, generic checkpointing poses
difficulties in many ways. Fortunatelly, the Python checkpointing module
presented in this section provides a comfortable workflow for an almost
generic checkpointing.

The idea is to let the user initially define which data is of interest
for checkpointing and thus solve the above mentioned problem. Once this
is done, checkpoints can then be saved simply by calling one save
function.

The checkpoint data can then later be restored easily by calling one
load function that will automatically process the checkpoint data by
setting the user variables and the checkpointed properties in .

In addition, the checkpointing module is also able to catch signals that
are invoked for example when the simulation is aborted by the user or by
a timeout.

The checkpointing module can be imported with

from espressomd import checkpointing

[ checkpoint\_path= ]

Determines the identifier for a checkpoint. Legal characters for an id
are “0-9”, “a-zA-Z”, “-”, “\_”.

Specifies the relative or absolute path where the checkpoints are
stored.

For example,

checkpoint = checkpointing.Checkpointing(checkpoint\_id=“mycheckpoint”)

would create the new checkpoint with id “mycheckpoint” and all the
checkpointing data will be stored in the current directory.

After the system and checkpointing user variables are set up they can be
registered for checkpointing:

[ , ]

Name string of the object or user variable that should be registered for
checkpointing.

To give an example,

myvar = “some variable value” skin = 0.4 checkpoint.register(“myvar”)
checkpoint.register(“skin”)

system = espressomd.System() # ... set system properties like box\_l or
timestep here ... checkpoint.register(“system”)

system.thermostat.set\_langevin(kT=1.0, gamma=1.0)
checkpoint.register(“system.thermostat”)

# ... set system.non\_bonded\_inter here ...
checkpoint.register(“system.non\_bonded\_inter”)

# ... add particles to the system with system.part.add(...) here ...
checkpoint.register(“system.part”)

# ... set charges of particles here ... from espressomd import
electrostatics p3m = electrostatics.P3M(bjerrum\_length=1.0,
accuracy=1e-2) system.actors.add(p3m) checkpoint.register(“p3m”)

will register the user variables and , system properties, a langevin
thermostat, non-bonded interactions, particle properties and a p3m
object for checkpointing. It is important to note that the checkpointing
of will only save basic system properties. This excludes for example the
system thermostat or the particle data. For this reason one has to
explicitly register and for checkpointing.

Analogous to this, objects that have been registered for checkpointing
but are no longer needed in the next checkpoints can be unregistered
with

[ , ]

A list of all registered object names can be generated with

A new checkpoint with a consecutive index that contains the latest data
of the registered objects can then be created by calling

An existing checkpoint can be loaded with

[ checkpoint\_index= ]

If no is passed the last checkpoint will be loaded. Concerning the
procedure of registering objects for checkpointing it is good to know
that all registered objects saved in a checkpoint will be automatically
re-registered after loading this checkpoint.

In practical implementations it might come in handy to check if there
are any available checkpoints for a given checkpoint id. This can be
done with

which returns a bool value.

As mentioned in the introduction the checkpointing module also enables
to catch signals in order to save a checkpoint and quit the simulation.
Therefore one has to register the signal which should be caught with

The registered signals are associated with the and will be automatically
re-registered when the same checkpoint id is used later.

Following the example above, the next example loads the last checkpoint,
restores the state of all checkpointed objects and registers a signal.

import espressomd from espressomd import checkpointing import signal

checkpoint = checkpointing.Checkpointing(checkpoint\_id=“mycheckpoint”)
checkpoint.load()

system = espressomd.System() system.cell\_system.skin = skin
system.actors.add(p3m)

#signal.SIGINT: signal 2, is sent when ctrl+c is pressed
checkpoint.register\_signal(signal.SIGINT)

# integrate system until user presses ctrl+c while True:
system.integrator.run(1000)

The above example runs as long as the user interrupts by pressing
ctrl+c. In this case a new checkpoint is written and the simulation
quits.

It is perhaps surprising that one has to explicitly create again. But
this is necessary as not all modules like or have implementations for
checkpointing yet. By calling these modules are created and can be
easily initialized with checkpointed user variables (like ) or
checkpointed submodules (like ).

Writing H5MD-files
------------------

For large amounts of data it’s a good idea to store it in the hdf5 (H5MD
is based on hdf5) file format (see https://www.hdfgroup.org/ for
details). currently supports some basic functions for writing simulation
data to H5MD files.

: Initialize a H5MD data file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

h5md\_init []

The command initializes the H5MD file and creates groups and datasets
according to the conventions of H5MD (see http://nongnu.org/h5md/). In
order to safely start from a checkpoint the init command automatically
copies the old file to a new file with a “tmp” suffix. The optional
argument can be provided. In this case observables are written for these
particle ids only.

: Write particle positions to H5MD file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

h5md\_write\_positions

Writes the positions of all particles to the dataset which was
previously initialized by ``h5md_init``.

: Write particle velocities to H5MD file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

h5md\_write\_velocities

Writes the velocities of all particles to the dataset which was
previously initialized by ``h5md_init``.

h5md\_write\_forces

Writes the forces of all particles to the dataset which was previously
initialized by ``h5md_init``.

: Initialize a user-defined H5MD observable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

h5md\_observable1D\_init

Initializes an observable dataset of a zero dimensional, but
timedependent, observable with given name in the H5MD file previously
initialized by ``h5md_init``.

: Write to a user-defined H5MD dataset
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

h5md\_observable1D\_write

Writes ``value`` to a user-defined observable dataset with given name.

h5md\_observable2D\_init

Initializes an observable dataset of a one dimensional, but
timedependent, observable with given *property* of particles in Espresso
in the H5MD file previously initialized by ``h5md_init``.

: Write to a user-defined H5MD dataset
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

h5md\_observable2D\_write

Writes ``value`` to a user-defined observable dataset with given name.

: Close H5MD file
~~~~~~~~~~~~~~~~~

h5md\_close

Closes the H5MD data file.

Writing H5MD-files with Python
------------------------------

To write data in a hdf5-file, first an object of the class ``H5md`` has
to be created and linked to the respective hdf5-file. This may, for
example, look like:

from espressomd.io.writer import h5md # add particles here system =
espressomd.System() h5=h5md.H5md(filename=“trajectory.h5”,
write\_pos=True, write\_vel=True)

If a file with the given filename exists and has a valid H5MD structures
it will be backed up to a file with suffix “.bak”. This file will be
removed by the close() method of the class which has to be called at the
end of the simulation to close the file. The current implementation
allows to write the following properties: positions, velocities, forces,
types, and masses of the particles. In order to write any property, you
have to set the respective boolean flag as an option to the H5md class.
Currently available:

-  write\_pos

-  write\_vel

-  write\_force

-  write\_type

-  write\_mass.

In simulations with varying numbers of particles (MC or reactions), the
size of the dataset will be adapted if the maximum number of particles
increases but will not be decreased. Instead a negative fill value will
be written to the trajectory for the id. If you have a parallel
simulation please keep in mind that the sequence of particles in general
changes from timestep to timestep. Therefore you have to always use the
dataset for the ids to track which position/velocity/force/type/mass
entry belongs to which particle. To write data to the hdf5 file, simply
call the H5md objects write method without any arguments.

h5.write()

After the last write call, you have to call the close() method to remove
the backup file and to close the datasets etc.

Writing and reading binary files
--------------------------------

Binary files are written using the command

writemd …

This will write out particle data to the Tcl channel for all particles
in binary format. Apart from the mandatory particle id, only limited
information can be stored. The coordinates (, and ), velocities (, and )
and forces (, and ). Other information should be stored in a blockfile
or reconstructed differently. Note that since both ``blockfile`` and
``writemd`` are using a Tcl channel, it is actually possible to mix
them, so that you can write a single checkpoint file. However, the
``blockfile read auto`` mechanism cannot handle the binary section, thus
you need to read this section manually. Reading of binary particle data
happens through

readmd

For the exact format of the written binary sequence, see
``src/tcl/binary_file_tcl.cpp``.

MPI-IO
------

When using with MPI, blockfiles and writemd have the disadvantage, that
the master node does *all* the output. This is done by sequentially
communicating all particle data to the master node. MPI-IO offers the
possibility to write out particle data in parallel using binary IO. To
output variables and other non-array information, use normal blockfiles
(section [sec:structured-file-format]).

To dump data using MPI-IO, use the following syntax:

mpiio …

This command writes data to several files using as common filename
prefix. Beware, that must not be a Tcl channel but a string which must
not contain colons. The data can be positions (), velocities (),
particle types () and particle bonds () or any combination of these. The
particle ids are always dumped. For safety reasons, MPI-IO will not
overwrite existing files, so if the command fails and prints
``MPI_ERR_IO`` make sure the files are non-existent.

The files produced by this command are (assumed is “1”):

1.head
    Internal information (Dumped fields, bond partner num); always
    produced

1.pref
    Internal information (Exscan results of nlocalparts); always
    produced

1.ids
    Particle ids; always produced

1.type
    Particle types; optional

1.pos
    Particle positions; optional

1.vel
    Particle velocities; optional

1.bond
    Bond information; optional

1.boff
    Internal bond prefix information; optional, necessary to read 1.bond

Currently, these files have to be read by exactly the same number of MPI
processes that was used to dump them, otherwise an error is signalled.
Also, the same type of machine (endianess, byte order) has to be used.
Otherwise only garbage will be read. The read command replaces the
particles, i.e. all previous existent particles will be *deleted*.

There is a python script (``tools/mpiio2blockfile.py``) which converts
MPI-IO snapshots to regular blockfiles.

Writing VTF files
-----------------

The formats VTF (**V**\ TF **T**\ rajectory **F**\ ormat), VSF
(**V**\ TF **S**\ tructure **F**\ ormat) and VCF (**V**\ TF
**C**\ oordinate **F**\ ormat) are formats for the visualization
software VMD:raw-latex:`\cite{humphrey96a}` [1]_. They are intended to
be human-readable and easy to produce automatically and modify.

The format distinguishes between *structure blocks* that contain the
topological information of the system (the system size, particle names,
types, radii and bonding information, amongst others), while *coordinate
blocks* (a.k.a. as *timestep blocks*) contain the coordinates for the
particles at a single timestep. For a visualization with VMD, one
structure block and at least one coordinate block is required.

Files in the VSF format contain a single structure block, files in the
VCF format contain at least one coordinate block, while files in the VTF
format contain a single structure block first and an arbitrary number of
coordinate blocks afterwards, thus allowing to store all information for
a whole simulation in a single file. For more details on the format,
refer to the homepage of the format [2]_.

Creating files in these formats from within is supported by the commands
and , that write a structure respectively a coordinate block to the
given Tcl channel. To create a VTF file, first use at the beginning of
the simulation, and then ``writevcf`` after each timestep to generate a
trajectory of the whole simulation.

The structure definitions in the VTF/VSF formats are incremental, a user
can easily add further structure lines to the VTF/VSF file after a
structure block has been written to specify further particle properties
for visualization.

Note that the ids of the particles in and VMD may differ. VMD requires
the particle ids to be enumerated continuously without any holes, while
this is not required in . When using and , the particle ids are
automatically translated into VMD particle ids. The function allows the
user to get the VMD particle id for a given particle id.

Also note, that these formats can not be used to write trajectories
where the number of particles or their types varies between the
timesteps. This is a restriction of VMD itself, not of the format.

``writevsf``: Writing the topology
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

writevsf

Writes a structure block describing the system’s structure to the
channel given by . must be an identifier for an open channel such as the
return value of an invocation of . The output of this command can be
used for a standalone VSF file, or at the beginning of a VTF file that
contains a trajectory of a whole simulation.

``writevcf``: Writing the coordinates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

writevcf

Writes a coordinate (or timestep) block that contains all coordinates of
the system’s particles to the channel given by . must be an identifier
for an open channel such as the return value of an invocation of .

Specify, whether the output is in a human-readable, but somewhat longer
format (), or in a more compact form (). The default is .

Specify whether the particle positions are written in absolute
coordinates () or folded into the central image of a periodic system ().
The default is .

Specify the coordinates of which particles should be written. If is
used, all coordinates will be written (in the ordered timestep format).
Otherwise, has to be a Tcl-list specifying the pids of the particles.
The default is . ``pids {0 23 42}``

Specify arbitrary user data for the particles. has to be a Tcl list
containing the user data for every particle. The user data is appended
to the coordinate line and can be read into VMD via the VMD plugin
``VTFTools``. The default is to provide no userdata.
``userdata {"red" "blue" "green"}``

``vtfpid``: Translating particles ids to VMD particle ids
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

vtfpid

If is the id of a particle as used in , this command returns the atom id
used in the VTF, VSF or VCF formats.

``writevtk``: Particle Visualization in paraview
------------------------------------------------

This feature allows to export the particle positions in a paraview  [3]_
compatible VTK file. Paraview is a powerful and easy to use open-source
visualization program for scientific data. Since can export the
lattice-Boltzmann velocity field [ssec:LBvisualization] in the VTK
format as well and paraview allows to visualize particles with glyphs
and vector fields with stream lines, glyphs, contourplots, etc., one can
use it so completely visualize a coupled lattice-Boltzmann MD
simulation. It can also create videos without much effort if one exports
data of individual time steps into separate files with filenames
including a running index (``data_0.vtk``, ``data_1.vtk``, ...).

writevtk

Name of the file to export the particle positions into.

Specifies a list of particle types which should be exported. The default
is . Alternatively, a list of type number can be given. Exporting the
positions of all particles but in separate files might make sense if one
wants to distinguish the different particle types in the visualization
(i.e. by color or size). To export a type ``1`` use something along
``writevtk test.tcl 1``. To export types ``1``, ``5``, ``7``, which are
not to be distinguished in the visualization, use
``writevtk test.tcl 7 1 5``. The order in the list is arbitrary, but
duplicates are *not* ignored!

Reading and Writing PDB/PSF files
---------------------------------

The PDB (Brookhaven Protein DataBase) format is a widely used format for
describing atomistic configurations. PSF is a format that is used to
describe the topology of a PDB file.

When visualizing your system with VMD, it is recommended to use the VTF
format instead (see section [sec:vtf]), as it was specifically designed
for visualizations with VMD. In contrast to the PDB/PSF formats, in VTF
files it is possible to specify the VDW radii of the particles, to have
a varying simulation box size, etc.

: Writing the topology
~~~~~~~~~~~~~~~~~~~~~~

writepsf

Writes the current topology to the file (here, is not a channel, since
additional information cannot be written anyway). , and so on are
parameters describing a system consisting of equally long charged
polymers, counterions and salt. This information is used to set the
residue name and can be used to color the atoms in VMD. If you specify ,
the residue name is taken from the molecule identity of the particle. Of
course different kinds of topologies can also be handled by modified
versions of .

: Writing the coordinates
~~~~~~~~~~~~~~~~~~~~~~~~~

writepdb writepdbfoldchains writepdbfoldtopo

Variant writes the corresponding particle data.

Variant writes folded particle data where the folding is performed on
chain centers of mass rather than single particles. In order to fold in
this way the chain topology and box length must be specified. Note that
this method is outdated. Use variant instead.

Variant writes folded particle data where the folding is performed on
chain centers of mass rather than single particles. This method uses the
internal box length and topology information from espresso. If you wish
to shift particles prior to folding then supply the optional shift
information. should be a three member tcl list consisting of x, y, and z
shifts respectively and each number should be a floating point (ie with
decimal point).

: Reading the coordinates and interactions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

| readpdb pdb\_file type first\_id

Reads the positions and possibly charges, types and Lennard-Jones
interactions from the file and a corresponding Gromacs topology file .
The topology file must contain the ``atoms`` and ``atomtypes`` sections,
it may be necessary to use the Gromacs preprocessor to obtain a complete
file from a system configuration and a force field.

Any offset of the particle positions if removed, such that the lower
left corner bounding box of the particles is in the origin. If
``fit_to_box`` is given, the box size if increased to hold the particles
if necessary. If it is not set and the particles do not fit into the
box, the behavior is undefined.

sets the particle type for the added particles. If there is a topology
file give that contains a types for the particles, the particles get
types by the order in the topology file plus . If the corresponding type
in the topology file has a charge, it is used, otherwise the particle
charge defaults to zero.

The particles get consecutive id’s in the order of the pdb file,
starting at . Please be aware that existing particles get overwritten by
values from the file.

The ``lj_with`` section produces Lennard-Jones interactions between the
type and the types defined by the topology file. The interaction
parameters are calculated as :math:`\epsilon_{\text{othertype},j} =
\sqrt{\epsilon_{\text{othertype}} \epsilon_j}` and
:math:`\sigma_{\text{othertype},j}
=\frac{1}{2}\left( \sigma_{\text{othertype}} + \sigma_j \right)`, where
:math:`j` runs over the atomtypes defined in the topology file. This
corresponds to the combination rule 2 of Gromacs. There may be multiple
such sections. The cutoff is determined by as
:math:`\text{cutoff}\times \sigma_{ij}` in a relative fashion. The
potential is shifted so that it vanishes at the cutoff. The command
returns the number of particles that were successfully added.

Reading bonded interactions and dihedrals is currently not supported.

Online-visualisation with VMD
-----------------------------

IMD (Interactive Molecular Dynamics) is the protocol that VMD uses to
communicate with a simulation. Tcl\_md implements this protocol to allow
online visual analysis of running simulations.

In IMD, the simulation acts as a data server. That means that a
simulation can provide the possibility of connecting VMD, but VMD need
not be connected all the time. You can watch the simulation just from
time to time.

In the following the setup and usage of IMD is described.

``imd``: Using IMD in the script
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

imd connect imd positions imd listen imd disconnect

In your simulation, the IMD connection is setup up using variant , where
is an arbitrary port number (which usually has to be between 1024 and
65000). By default, will try to open port :math:`10000`, but the port
may be in use already by another simulation. In that case it is a good
idea to just try another port.

While the simulation is running, variant can be used to transfer the
current coordinates to VMD, if it is connected. If not, nothing happens
and the command just consumes a small amount of CPU time. Note, that
before you can transfer coordinates to VMD, VMD needs to be aware of the
structure of the system. For that, you first need to load a
corresponding structure file (PSF or VSF) into VMD. Also note, that the
command (see section ) can be used to automatically set up the VMD
connection and transfer the structure file.

By specifying , the unfolded coordinates of the particles will
transferred, while will fold chains according to their centers of mass
and retains bonding connectivity. Note that this requires the chain
structure to be specified first using the analyze command.

Variant can be used to let the simulation wait for seconds or until IMD
has connected, before the script is continued. This is normally only
useful in demo scripts, if you want to see all frames of the simulation.

Variant will terminate the IMD session. This is normally not only nice
but also the operating system will not free the port for some time, so
that without disconnecting for some 10 seconds you will not be able to
reuse the port.

Using IMD in VMD
~~~~~~~~~~~~~~~~

The PDB/PSF files created by via the command and can be loaded into VMD.
This should bring up an initial configuration.

Then you can use the VMD console to execute the command

imd connect

where is the host running the simulation and is the port it listens to.
Note that VMD crashes, if you do that without loading a structure file
before. For more information on how to use VMD to extract more
information or hide parts of configuration, see the VMD Quick Help.

Automatically setting up a VMD connection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

prepare\_vmd\_connection ... prepare\_vmd\_connection

To reduce the effort involved in setting up the IMD connection, starting
VMD and loading the structure file, provides the command . It writes out
the required vsf structure description file to .vsf (default for is ),
doing some nice stuff such as coloring the molecules, bonds and
counterions appropriately, rotating your viewpoint, and connecting your
system to the visualization server.

If the option is given, then the command will create graphics primitives
in VMD that represent some of the spatial constraints (sphere, rhomboid
and cylinder at present).

If is given, the command will automatically try to start VMD and connect
it to the simulation. Otherwise it only writes the VMD setup script .
You can use this script later to connect to the simulation by running
either

vmd -e vmd\_start.script

or by running

source “vmd\_start.script”

at VMD’s Tcl console. If you choose to not start VMD automatically, puts
the hostname into the VMD script, so that you can start it from any
computer. However, some more recent Linux distributions block any
incoming transfer even from the computer itself, if it does not come
from localhost. If you encounter problems to connect to VMD on the very
same computer, try the option, which will enforce to use the hostname .
Note that the option implies the option, since VMD is necessarily
started from the same computer.

If the option is provided, then the command waits for at most seconds
for VMD to connect. Since VMD usually takes a while to start, it is
usually a good idea to combine the option with a waiting time of 100, so
a bit less than a minute.

All remaining parameters are passed to the that is used to setup the
system, so that you can specify the sizes of particles etc.

also supports an older, deprecated syntax (variant 2) with limited
functionality. This syntax uses fixed position parameters and boolean
values for and , as described above.

Error handling
--------------

Errors in the parameters are detected as early as possible, and
hopefully self-explanatory error messages returned without any changes
to the data in the internal data of . This include errors such as
setting nonexistent properties of particles or simply misspelled
commands. These errors are returned as standard Tcl errors and can be
caught on the Tcl level via

catch script err

When run noninteractively, Tcl will return a nice stack backtrace which
allows to quickly find the line causing the error.

However, some errors can only be detected after changing the internal
structures, so that is left in a state such that integration is not
possible without massive fixes by the users. Especially errors occuring
on nodes other than the primary node fall under this condition, for
example a broken bond or illegal parameter combinations.

For error conditions such as the examples given above, a Tcl error
message of the form

background 0 1

is returned. Following possibly a normal Tcl error message, after the
background keyword all severe errors are listed node by node, preceeded
by the node number. A special error is , which means that one of the
slave nodes found exactly the same errors as the master node. This
happens mainly during the initialization of the integrate, if the time
step is not set. In this case the error message will be

background\_errors 0 {time\_step not set} 1 <consent>

In each case, the current action was not fulfilled, and possibly other
parts of the internal data also had to be changed to allow to continue,
so you should really know what you do if you try and catch these errors.

Online-visualisation with Mayavi or OpenGL
------------------------------------------

With the python interface, features two possibilities for
online-visualization:

#. Using the mlab module to drive *Mayavi, a “3D scientific data
   visualization and plotting in Python”*. Mayavi has a user-friendly
   GUI to specify the appearance of the output. Additional requirements:
   python module *mayavi*, VTK (package *python-vtk* for Debian/Ubuntu).
   Note that only VTK from version 7.0.0 and higher has Python 3
   support.

#. A direct rendering engine based on *pyopengl*. As it is developed for
   , it supports the visualization of several specific features like
   external forces or constraints. It has no GUI to setup the
   appearance, but can be adjusted by a large set of parameters.
   Additional requirements: python module *PyOpenGL*.

Both are not meant to produce high quality renderings, but rather to
debug your setup and equilibration process.

General usage
~~~~~~~~~~~~~

The recommended usage of both tools is similar: Create the visualizer of
your choice and pass it the ``espressomd.System()`` object. Then write
your integration loop in a seperate function, which is started in a
non-blocking thread. Whenever needed, call ``update()`` to synchronize
the renderer with your system. Finally start the blocking visualization
window with ``start()``. See the following minimal code example:

import espressomd from espressomd import visualization from threading
import Thread

system = espressomd.System() system.cell\_system.skin = 0.4
system.time\_step = 0.01 system.box\_l = [10,10,10]

system.part.add(pos = [1,1,1]) system.part.add(pos = [9,9,9])

visualizer = visualization.mayaviLive(system) #visualizer =
visualization.openGLLive(system)

def main\_thread(): while True: system.integrator.run(1)
visualizer.update()

t = Thread(target=main\_thread) t.daemon = True t.start()

visualizer.start()

Common methods
~~~~~~~~~~~~~~

Starts the blocking visualizer window.

Synchonizes system and visualizer, handles keyboard events for
openGLLive.

[ interval= ]

Registers the method , which is called every milliseconds. Useful for
live plotting (see sample script samples/python/visualization.py)

Mayavi visualizer
~~~~~~~~~~~~~~~~~

The mayavi visualizer is created with the following syntax:

[ particle\_sizes= ]

The espressomd.System() object.

(default): The Lennard-Jones sigma value of the self-interaction is used
for the particle diameter. : A lambda function with one argument.
Internally, the numerical particle type is passed to the lambda function
to determine the particle radius. : A list of particle radii, indexed by
the particle type.

OpenGL visualizer
~~~~~~~~~~~~~~~~~

[ window\_size=, name=, background\_color=, periodic\_images=,
draw\_box=, quality\_spheres=, quality\_bonds=, quality\_arrows=,
close\_cut\_distance=, far\_cut\_distance=, camera\_position=,
camera\_rotation=, particle\_sizes=, particle\_coloring=,
particle\_type\_colors=, particle\_type\_materials=,
particle\_charge\_colors=, draw\_constraints=, rasterize\_pointsize=,
rasterize\_resolution=, quality\_constraints=,
constraint\_type\_colors=, constraint\_type\_materials=, draw\_bonds=,
bond\_type\_radius=, bond\_type\_colors=, bond\_type\_materials=,
ext\_force\_arrows=, ext\_force\_arrows\_scale=, drag\_enabled=,
drag\_force=, light\_pos=, light\_color=, light\_brightness=,
light\_size= ]

The espressomd.System() object.

Size of the visualizer window in pixels.

The name of the visualizer window.

RGB of the background.

Periodic repetitions on both sides of the box in xyz direction.

Draw wireframe boundaries.

The number of subdivisions for spheres.

The number of subdivisions for cylindrical bonds.

The number of subdivisions for external force arrows.

The distance from the viewer to the near clipping plane.

The distance from the viewer to the far clipping plane.

Initial camera position.

Initial camera angles.

| (default): The Lennard-Jones sigma value of the self-interaction is
  used for the particle diameter.
| : A lambda function with one argument. Internally, the numerical
  particle type is passed to the lambda function to determine the
  particle radius.
| : A list of particle radii, indexed by the particle type.

| (default): Colors of charged particles are specified by , neutral
  particles by
| : Minimum and maximum charge of all particles is determined by the
  visualizer. All particles are colored by a linear interpolation of the
  two colors given by according to their charge.
| : Particle colors are specified by , indexed by their numerical
  particle type.

Colors for particle types.

Materials of the particle types.

Two colors for min/max charged particles.

Enables constraint visualization. For simple constraints. (planes,
spheres and cylinders), OpenGL primitives are used. Otherwise,
visualization by rasterization is used.

Point size for the rasterization dots.

Accuracy of the rasterization.

The number of subdivisions for primitive constraints.

Colors of the constaints by type.

Materials of the constraints by type.

Enables bond visualization.

Radii of bonds by type.

Color of bonds by type.

Materials of bonds by type.

Enables external force visualization.

Scale factor for external force arrows.

Enables mouse-controlled particles dragging (Default: False)

Factor for particle dragging

If (default) is used, the light is placed dynamically in the particle
barycenter of the system. Otherwise, a fixed coordinate can be set.

Light color

Brightness (inverse constant attenuation) of the light.

Size (inverse linear attenuation) of the light.

The optional parameters to adjust the appearance of the visualization
have suitable default values for most simulations. Colors for particles,
bonds and constraints are specified by RGBA arrays, materials by an
array for the ambient, diffuse and specular (ADS) components. To
distinguish particle groups, arrays of RGBA or ADS entries are used,
which are indexed circularly by the numerical particle type.

Keyboard controls
^^^^^^^^^^^^^^^^^

The camera is controlled via mouse (camera look direction),
WASD-Keyboard control (WS: move forwards/backwards, AD: move sidewards)
and the key pairs QE, RF, ZC (camera roll). With the keyword
``drag_enabled`` set to ``True``, the mouse can be used to exert a force
on particles in drag direction (scaled by ``drag_force`` and the
distance of particle and mouse cursor). Additional input functionality
for mouse and keyboard is possible by assigning callbacks to specified
keyboard or mouse buttons. This may be useful for realtime adjustment of
system parameters (temperature, interactions, particle properties etc)
of for demonstration purposes. An example can be found in
samples/python/billard.py.

Visualization example scripts
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Various example scripts can be found in the samples/python folder or in
some tutorials:

-  samples/python/visualization.py: LJ-Liquid with live plotting.

-  samples/python/visualization\_bonded.py: Sample for bond
   visualization.

-  samples/python/billard.py: Simple billard game including many
   features of the openGL visualizer.

-  samples/python/visualization\_openGL.py: Timer and keyboard callbacks
   for the openGL visualizer.

-  doc/tutorials/python/02-charged\_system/scripts/nacl\_units\_vis.py:
   Periodic NaCl crystal, see tutorial “Charged Systems”.

-  doc/tutorials/python/02-charged\_system/scripts/nacl\_units\_confined\_vis.py:
   Confined NaCl with interactively adjustable electric field, see
   tutorial “Charged Systems”.

-  doc/tutorials/python/08-visualization/scripts/visualization.py:
   LJ-Liquid visualization along with tutorial “Visualization”.

Finally, it is recommended to go through tutorial “Visualization” for
further code explanations. Also, the tutorial “Charged Systems” has two
visualization examples.

.. [1]
   http://www.ks.uiuc.edu/Research/vmd/

.. [2]
   https://github.com/olenz/vtfplugin/wiki/VTF-format

.. [3]
   http://www.paraview.org/
