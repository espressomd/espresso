##
# Copyright (C) 2013,2014,2015,2016 The ESPResSo project
#
# This file is part of ESPResSo.
#
# ESPResSo is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# ESPResSo is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
from __future__ import print_function, absolute_import
include "myconfig.pxi"

cimport numpy as np
import numpy as np
from . cimport utils
from espressomd.utils cimport *
from . cimport particle_data
from .interactions import BondedInteraction
from .interactions import BondedInteractions
from copy import copy
from globals cimport max_seen_particle, time_step, smaller_time_step, box_l, n_part, n_rigidbonds, n_particle_types
import collections
import functools

PARTICLE_EXT_FORCE = 1


def _COORD_FIXED(coord):
    return 2L << coord


COORDS_FIX_MASK = _COORD_FIXED(0) | _COORD_FIXED(1) | _COORD_FIXED(2)
COORDS_ALL_FIXED = _COORD_FIXED(0) & _COORD_FIXED(1) & _COORD_FIXED(2)
PARTICLE_EXT_TORQUE = 16
ROT_X=2
ROT_Y=4
ROT_Z=8

# List of particle attributes for pickle and the like
# Autogenerated from the class. Everything which is of the same
# type as ParticleHandle.pos (getter_wrapper)
particle_attributes = []
for d in dir(ParticleHandle):
    if type(getattr(ParticleHandle, d)) == type(ParticleHandle.pos):
        if not d in ["pos_folded"]:
            particle_attributes.append(d)


cdef class ParticleHandle(object):
    def __cinit__(self, _id):
        self.id = _id

    cdef int update_particle_data(self) except -1:
        self.particle_data = get_particle_data(self.id)
        if not self.particle_data:
            raise Exception(
                "Error updating particle data for id " + str(self.id))
        else:
            return 0

    def __str__(self):
        res = collections.OrderedDict()
        # Id and pos first, then the rest
        res["id"] = self.id
        res["pos"] = self.pos
        for a in particle_attributes:
            tmp = getattr(self, a)
            # Remove array type names from output
            if isinstance(tmp, np.ndarray):
                res[a] = tuple(tmp)
            else:
                res[a] = tmp

        # Get rid of OrderedDict in output
        return str(res).replace("OrderedDict(", "ParticleHandle(")

    # The individual attributes of a particle are implemented as properties.

    # Particle Type
    property type:
        """
        The particle type for nonbonded interactions.

        type : :obj:`int`
               Nonbonded interactions act between different types of particles.

        .. note::
           The value of `type` has to be an integer >= 0.

        """

        def __set__(self, _type):

            if isinstance(_type, int) and _type >= 0:
                if set_particle_type(self.id, _type) == 1:
                    raise Exception("Set particle position first.")
            else:
                raise ValueError("type must be an integer >= 0")

        def __get__(self):
            self.update_particle_data()
            return self.particle_data.get()[0].p.type

    # Particle MolId
    property mol_id:
        """
        The molecule id of the Particle.

        mol_id : :obj:`int`
                 The particle mol_id is used to differentiate between
                 particles belonging to different molecules, e.g. when virtual
                 sites are used, or object-in-fuid cells. The default
                 `mol_id` for all particles is 0.

        .. note::
           The value of `mol_id` has to be an integer >= 0.

        """

        def __set__(self, _mol_id):
            if isinstance(_mol_id, int) and _mol_id >= 0:
                if set_particle_mol_id(self.id, _mol_id) == 1:
                    raise Exception("Set particle position first.")
            else:
                raise ValueError("mol_id must be an integer >= 0")

        def __get__(self):
            self.update_particle_data()
            return self.particle_data.get()[0].p.mol_id

    # Position
    property pos:
        """
        The unwrapped (not folded into central box) particle position.

        pos : list of :obj:`float`
              A list of three floats representing the particles's absolute position.

        """

        def __set__(self, _pos):
            cdef double mypos[3]
            check_type_or_throw_except(
                _pos, 3, float, "Postion must be 3 floats")
            for i in range(3):
                mypos[i] = _pos[i]
            if place_particle(self.id, mypos) == -1:
                raise Exception("particle could not be set")

        def __get__(self):
            self.update_particle_data()
            cdef double ppos[3]
            cdef int img[3]
            for i in range(3):
                img[i] = self.particle_data.get()[0].l.i[i]
                ppos[i] = self.particle_data.get()[0].r.p[i]

            unfold_position(ppos, img)
            return np.array([ppos[0], ppos[1], ppos[2]])

    property pos_folded:
        """
        The wrapped (folded into central box) position vector of a particle.

        pos : list of :obj:`float`
              A list of three floats representing the particles's position.

        .. note::
           Setting the folded position is ambiguous and is thus not possible, please use `pos`.

        Examples
        --------
        >>> import espressomd
        >>>
        >>> system = espressomd.System()
        >>>
        >>> system.box_l=[10,10,10]
        >>> # add two bonded particles to particle 0
        >>> system.part.add(id=0, pos=(5, 0, 0))
        >>> system.part.add(id=1, pos=(10, 0, 0))
        >>> system.part.add(id=2, pos=(25, 0, 0))
        >>> for p in system.part:
        >>>     print(p.pos)
        [ 5.  0.  0.]
        [ 10.   0.   0.]
        [ 25.   0.   0.]
        >>>
        >>> for p in system.part:
        >>>     print(p.pos_folded)
        [5.0, 0.0, 0.0]
        [0.0, 0.0, 0.0]
        [5.0, 0.0, 0.0]

        """
        def __set__(self, pos_folded):
            raise Exception("setting a folded position is not implemented")

        def __get__(self):
            cdef double pos[3]
            pos = self.pos
            fold_position(pos, self.particle_data.get()[0].l.i)
            return pos

    # Velocity
    property v:
        """
        The particle velocity in the lab frame.

        v : list of :obj:`float`
            A list of three floats representing the Particles's velocity

        .. note::
           The velocity remains variable and will be changed during integration.

        """

        def __set__(self, _v):
            global time_step
            cdef double myv[3]
            check_type_or_throw_except(
                _v, 3, float, "Velocity has to be floats")
            for i in range(3):
                myv[i] = _v[i]
                myv[i] *= time_step
            if set_particle_v(self.id, myv) == 1:
                raise Exception("Set particle position first.")

        def __get__(self):
            global time_step, smaller_time_step
            self.update_particle_data()
            IF MULTI_TIMESTEP:
                if smaller_time_step > 0. and self.smaller_timestep:
                    return np.array([self.particle_data.get()[0].m.v[0] / smaller_time_step,
                                     self.particle_data.get()[0].m.v[
                                         1] / smaller_time_step,
                                     self.particle_data.get()[0].m.v[2] / smaller_time_step])
                else:
                    return np.array([self.particle_data.get()[0].m.v[0] / time_step,
                                     self.particle_data.get()[
                        0].m.v[1] / time_step,
                        self.particle_data.get()[0].m.v[2] / time_step])
            ELSE:
                return np.array([self.particle_data.get()[0].m.v[0] / time_step,
                                 self.particle_data.get()[
                    0].m.v[1] / time_step,
                    self.particle_data.get()[0].m.v[2] / time_step])

    # Force
    property f:
        """
        The instantaneous force acting on this particle.

        f : list of :obj:`float`
            A list of three floats representing the current forces on the Particle

        .. note::
           Whereas the velocity is modified with respect to the velocity you set
           upon integration, the force it recomputed during the integration step and any
           force set in this way is immediatly lost at the next integration step.

        """

        def __set__(self, _f):
            global time_step
            cdef double myf[3]
            check_type_or_throw_except(_f, 3, float, "Force has to be floats")
            for i in range(3):
                myf[i] = _f[i]
                myf[i] *= (0.5 * time_step**2)
            if set_particle_f(self.id, myf) == 1:
                raise Exception("Set particle position first.")

        def __get__(self):
            global time_step
            self.update_particle_data()
            return np.array([self.particle_data.get()[0].f.f[0] * self.particle_data.get()[0].p.mass / (0.5 * time_step**2),
                             self.particle_data.get()[
                0].f.f[1] * self.particle_data.get()[0].p.mass / (0.5 * time_step**2),
                self.particle_data.get()[0].f.f[2] * self.particle_data.get()[0].p.mass / (0.5 * time_step**2)])

    # Bonds
    property bonds:
        """
        The bonds stored by this particle. Note that bonds are only stored by one partner.
        You need to define a bonded interaction.

        bonds : tuple of tuples (or list)
                a bond tuple is specified as a bond identifier associated with
                a particle `(bond_ID, part_ID)`. A single particle may contain
                multiple such tuples.

        See Also
        --------
        add_bond() : Method to add bonds to a `Particle`
        delete_bond() : Method to add bonds to a `Particle`

        .. note::
           Bond ids have to be an integer >= 0.

        """

        def __set__(self, _bonds):
            # First, we check that we got a list/tuple.
            if not hasattr(_bonds, "__getitem__"):
                raise ValueError(
                    "Bonds have to specified as a tuple of tuples. (Lists can also be used).")
            bonds = list(_bonds)  # as we modify it

            # Assigning to the bond property means replacing the existing value
            # i.e., we delete all existing bonds
            if change_particle_bond(self.id, NULL, 1):
                handle_errors("Deleting existing bonds failed.")

            # And add the new ones
            for bond in bonds:
                self.add_bond(bond)

        def __get__(self):
            self.update_particle_data()
            bonds = []
            # Go through the bond list of the particle
            i = 0
            while i < self.particle_data.get()[0].bl.n:
                bond = []
                # Bond type:
                bond_id = self.particle_data.get()[0].bl.e[i]
                bond.append(BondedInteractions()[bond_id])
                # Number of partners
                nPartners = bonded_ia_params[bond_id].num

                i += 1

                # Copy bond partners
                for j in range(nPartners):
                    bond.append(self.particle_data.get()[0].bl.e[i])
                    i += 1
                bonds.append(tuple(bond))

            return tuple(bonds)

    # Properties that exist only when certain features are activated
    # MULTI_TIMESTEP
    IF MULTI_TIMESTEP == 1:
        property smaller_timestep:
            """
            smaller_timestep : :obj:`int`
                               Particle flag specifying whether particle trajectory
                               should be integrated with time_step of small_time_step.

            .. note::
               This needs the feature MULTI_TIMESTEP.

            """

            def __set__(self, _smaller_timestep):
                check_type_or_throw_except(
                    _smaller_timestep, 1, int, "Smaller time step flag has to be 1 ints")
                if set_particle_smaller_timestep(self.id, _smaller_timestep) == 1:
                    raise Exception("error setting particle smaller_timestep")

            def __get__(self):
                self.update_particle_data()
                cdef int * x = NULL
                pointer_to_smaller_timestep(self.particle_data.get(), x)
                return x[0]

    # MASS
    property mass:
        """
        Particle mass.

        mass : :obj:`float`
               The particle mass.

        See Also
        ----------
        :meth:`espressomd.thermostat.Thermostat.set_langevin` : Setting the parameters of the Langevin thermostat

        """

        def __set__(self, _mass):
            IF MASS == 1:
                check_type_or_throw_except(
                    _mass, 1, float, "Mass has to be 1 floats")
                if set_particle_mass(self.id, _mass) == 1:
                    raise Exception("Set particle position first.")
            ELSE:
                raise Exception("You are trying to set the particle mass \
                                     but the mass feature is not compiled in.")

        def __get__(self):
            self.update_particle_data()
            return self.particle_data.get()[0].p.mass

    IF ROTATION == 1:
        property omega_lab:
            """
            The particle angular velocity the lab frame.

            omega_lab : list of :obj:`float`
                        List of three floats giving the particle angular
                        velocity as measured from the lab frame.

            .. note::
               This needs the feature ROTATION.

               If you set the angular velocity of the particle in the lab
               frame, the orientation of the particle
               (:attr:`espressomd.particle_data.ParticleHandle.quat`) must be
               set before setting omega_lab, otherwise the conversion from
               lab to body frame will not be handled properly.

            See Also
            ---------
            :attr:`espressomd.particle_data.ParticleHandle.omega_body`

            """

            def __set__(self, _o):
                cdef double myo[3]
                check_type_or_throw_except(
                    _o, 3, float, "Omega_lab has to be 3 floats.")
                for i in range(3):
                    myo[i] = _o[i]
                if set_particle_omega_lab(self.id, myo) == 1:
                    raise Exception("Set particle position first.")

            def __get__(self):
                self.update_particle_data()
                cdef double o[3]
                convert_omega_body_to_space(self.particle_data.get(), o)
                return np.array([o[0], o[1], o[2]])

        property quat:
            """
            Particle quaternion representation.

            quat : list fo :obj:`float` (of length four)
                   This list of four floats sets the quaternion representation
                   of the rotational position of this particle.

            .. note::
               This needs the feature ROTATION.

            """

            def __set__(self, _q):
                cdef double myq[4]
                check_type_or_throw_except(
                    _q, 4, float, "Quaternions has to be 4 floats.")
                for i in range(4):
                    myq[i] = _q[i]
                if set_particle_quat(self.id, myq) == 1:
                    raise Exception("Set particle position first.")

            def __get__(self):
                self.update_particle_data()
                cdef double * x = NULL
                pointer_to_quat(self.particle_data.get(), x)
                return np.array([x[0], x[1], x[2], x[3]])

# Director ( z-axis in body fixed frame)
        property director:
            """
            Director.

            .. note::
               Setting the director is not implemented.
               This needs the feature ROTATION.

            """

            def __set__(self, _q):
                raise Exception(
                    "Setting the director is not implemented in the c++-core of Espresso.")
#        cdef double myq[3]
#        check_type_or_throw_except(_q,3,float,"Director has to be 3 floats")
#        for i in range(3):
#            myq[i]=_q[i]
#        if set_particle_quatu(self.id, myq) == 1:
#          raise Exception("Set particle position first.")

            def __get__(self):
                self.update_particle_data()
                cdef double * x = NULL
                pointer_to_quatu(self.particle_data.get(), x)
                return np.array([x[0], x[1], x[2]])

    # ROTATIONAL_INERTIA
        property omega_body:
            """
            The particle angular velocity in body frame.

            omega_body : list of :obj:`float`

            This property sets the angular momentum of this particle in the
            particles co-rotating frame (or body frame).

            .. note::
               This needs the feature ROTATION.

            """

            def __set__(self, _o):
                cdef double myo[3]
                check_type_or_throw_except(
                    _o, 3, float, "Omega_body has to be 3 floats.")
                for i in range(3):
                    myo[i] = _o[i]
                if set_particle_omega_body(self.id, myo) == 1:
                    raise Exception("Set particle position first.")

            def __get__(self):
                self.update_particle_data()
                cdef double * o = NULL
                pointer_to_omega_body(self.particle_data.get(), o)
                return np.array([o[0], o[1], o[2]])

        property torque_lab:
            """
            The particle torque in the lab frame.

            torque_lab : list of :obj:`float`

            This property defines the torque of this particle
            in the fixed frame (or laboratory frame).

            .. note::
               The orientation of the particle
               (:attr:`espressomd.particle_data.ParticleHandle.quat`) must be
               set before setting this property, otherwise the conversion from
               lab to body frame will not be handled properly.

            See also
            --------
            :attr:`espressomd.particle_data.ParticleHandle.torque_body`

            """

            def __set__(self, _t):
                cdef double myt[3]
                check_type_or_throw_except(
                    _t, 3, float, "Torque has to be 3 floats.")
                for i in range(3):
                    myt[i] = _t[i]
                if set_particle_torque_lab(self.id, myt) == 1:
                    raise Exception("Set particle position first.")

            def __get__(self):
                self.update_particle_data()
                cdef double x[3]
                convert_torques_body_to_space(self.particle_data.get(), x)
                return np.array([x[0], x[1], x[2]])

    IF ROTATIONAL_INERTIA == 1:
        property rinertia:
            """
            The particle rotational inertia.

            rintertia : list of :obj:`float`

            Sets the diagonal elements of this particles rotational inertia
            tensor. These correspond with the inertial moments along the
            coordinate axes in the particleâ€™s co-rotating coordinate system.
            When the particle's quaternions are set to 1 0 0 0, the co-rotating
            and the fixed (lab) frame are co-aligned.

            .. note::
               This needs the feature ROTATIONAL_INERTIA.

            """

            def __set__(self, _rinertia):
                cdef double rinertia[3]
                check_type_or_throw_except(
                    _rinertia, 3, float, "Rotation_inertia has to be 3 floats.")
                for i in range(3):
                    rinertia[i] = _rinertia[i]
                if set_particle_rotational_inertia(self.id, rinertia) == 1:
                    raise Exception("Set particle position first.")

            def __get__(self):
                self.update_particle_data()
                cdef double * rinertia = NULL
                pointer_to_rotational_inertia(
                    self.particle_data.get(), rinertia)
                return np.array([rinertia[0], rinertia[1], rinertia[2]])

# Charge
    IF ELECTROSTATICS == 1:
        property q:
            """
            Particle charge.

            q : :obj:`float`

            .. note::
               This needs the feature ELECTROSTATICS.

            """

            def __set__(self, _q):
                cdef double myq
                check_type_or_throw_except(
                    _q, 1, float, "Charge has to be floats.")
                myq = _q
                if set_particle_q(self.id, myq) == 1:
                    raise Exception("Set particle position first.")

            def __get__(self):
                self.update_particle_data()
                cdef double * x = NULL
                pointer_to_q(self.particle_data.get(), x)
                return x[0]

    IF VIRTUAL_SITES == 1:

        property virtual:
            """
            Virtual flag.
            Declares the particles as virtual (1) or non-virtual (0, default).

            virtual : integer

            .. note::
               This needs the feature VIRTUAL_SITES

            """

            def __set__(self, _v):
                if isinstance(_v, int):
                    if set_particle_virtual(self.id, _v) == 1:
                        raise Exception("Set particle position first.")
                else:
                    raise ValueError("virtual must be an integer >= 0.")

            def __get__(self):
                self.update_particle_data()
                cdef int * x = NULL
                pointer_to_virtual(self.particle_data.get(), x)
                return x[0]

    IF VIRTUAL_SITES_RELATIVE == 1:
        property vs_relative:
            """
            Virtual sites relative parameters.

            Allows for manual access to the attributes of virtual sites in the "relative"
            implementation. PID denotes the id of the particle to which this virtual site
            is related and distance the distance between non-virtual and virtual particle.
            The relative orientation is specified as a quaternion of 4 floats.

            vs_relative : tuple: (PID, distance, (q1,q2,q3,q4))

            .. note::
               This needs the feature VIRTUAL_SITES_RELATIVE

            """

            def __set__(self, x):
                if len(x) != 3:
                    raise ValueError(
                        "vs_relative needs input like id,distance,(q1,q2,q3,q4).")
                _relto = x[0]
                _dist = x[1]
                q = x[2]
                check_type_or_throw_except(
                    q, 4, float, "The relative orientation has to be specified as quaternion with 4 floats.")
                cdef double _q[4]
                for i in range(4):
                    _q[i] = q[i]

                if isinstance(_relto, int) and isinstance(_dist, float):
                    if set_particle_vs_relative(self.id, _relto, _dist, _q) == 1:
                        raise Exception("Set particle position first.")
                else:
                    raise ValueError(
                        "vs_relative takes one int and one float as parameters.")

            def __get__(self):
                self.update_particle_data()
                cdef int * rel_to = NULL
                cdef double * dist = NULL
                cdef double * q = NULL
                pointer_to_vs_relative(
                    self.particle_data.get(), rel_to, dist, q)
                return (rel_to[0], dist[0], np.array((q[0], q[1], q[2], q[3])))

        # vs_auto_relate_to
        def vs_auto_relate_to(self, _relto):
            """
            Setup this particle as virtual site relative to the particle with the given id.

            """

            check_type_or_throw_except(
                _relto, 1, int, "Argument of vs_auto_relate_to has to be of type int.")
            if vs_relate_to(self.id, _relto):
                handle_errors("vs_relative setup failed.")

    IF DIPOLES:
        property dip:
            """
            The orientation of the dipole axis.

            dip : list of :obj:`float`

            .. note::
               This needs the feature DIPOLES.

            """

            def __set__(self, _q):
                cdef double myq[3]
                check_type_or_throw_except(
                    _q, 3, float, "Dipole moment vector has to be 3 floats.")
                for i in range(3):
                    myq[i] = _q[i]
                if set_particle_dip(self.id, myq) == 1:
                    raise Exception("Set particle position first.")

            def __get__(self):
                self.update_particle_data()
                cdef double * x = NULL
                pointer_to_dip(self.particle_data.get(), x)
                return np.array([x[0], x[1], x[2]])

        # Scalar magnitude of dipole moment
        property dipm:
            """
            The magnitude of the dipole moment.

            dipm : :obj:`float`

            .. note::
               This needs the feature DIPOLES.

            """

            def __set__(self, _q):
                check_type_or_throw_except(
                    _q, 1, float, "Magnitude of dipole moment has to be 1 floats.")
                if set_particle_dipm(self.id, _q) == 1:
                    raise Exception("Set particle position first.")

            def __get__(self):
                self.update_particle_data()
                cdef double * x = NULL
                pointer_to_dipm(self.particle_data.get(), x)
                return x[0]

    IF EXTERNAL_FORCES:
        property ext_force:
            """
            An additional external force applied to the particle.

            ext_force : list of :obj:`float`

            .. note::
               This needs the feature EXTERNAL_FORCES.

            """

            def __set__(self, _ext_f):
                cdef double ext_f[3]
                cdef int ext_flag = 0
                check_type_or_throw_except(
                    _ext_f, 3, float, "External force vector has to be 3 floats.")
                for i in range(3):
                    ext_f[i] = _ext_f[i]
                if (ext_f[0] == 0 and ext_f[1] == 0 and ext_f[2] == 0):
                    ext_flag = 0
                else:
                    ext_flag = PARTICLE_EXT_FORCE
                if set_particle_ext_force(self.id, ext_flag, ext_f) == 1:
                    raise Exception("Set particle position first.")

            def __get__(self):
                self.update_particle_data()
                cdef double * ext_f = NULL
                cdef int * ext_flag = NULL
                pointer_to_ext_force(self.particle_data.get(), ext_flag, ext_f)
                if (ext_flag[0] & PARTICLE_EXT_FORCE):
                    return np.array([ext_f[0], ext_f[1], ext_f[2]])
                else:
                    return np.array([0.0, 0.0, 0.0])

        property fix:
            """
            Fixes the particle motion in the specified cartesian directions.

            fix : list of integers

            Fixes the particle in space. By supplying a set of 3 integers as
            arguments it is possible to fix motion in x, y, or z coordinates
            independently. For example::

                part[<INDEX>].fix = [0, 0, 1]

            will fix motion for particle with index ``INDEX`` only in z.

            .. note::
               This needs the feature EXTERNAL_FORCES.

            """

            def __set__(self, _fixed_coord_flag):
                cdef int ext_flag = 0
                check_type_or_throw_except(
                    _fixed_coord_flag, 3, int, "Fix has to be 3 ints.")
                for i in map(long, range(3)):
                    if (_fixed_coord_flag[i]):
                        ext_flag |= _COORD_FIXED(i)
                if set_particle_fix(self.id, ext_flag) == 1:
                    raise Exception("Set particle position first.")

            def __get__(self):
                self.update_particle_data()
                fixed_coord_flag = np.array([0, 0, 0], dtype=int)
                cdef int * ext_flag = NULL
                pointer_to_fix(self.particle_data.get(), ext_flag)
                for i in map(long, range(3)):
                    if (ext_flag[0] & _COORD_FIXED(i)):
                        fixed_coord_flag[i] = 1
                return fixed_coord_flag

        IF ROTATION:
            property ext_torque:
                """
                An additional external torque is applied to the particle.

                ext_torque : list of :obj:`float`

                ..  note::
                    * This torque is specified in the laboratory frame!
                    * This needs the feature EXTERNAL_FORCES and ROTATION.

                """

                def __set__(self, _ext_t):
                    cdef double ext_t[3]
                    cdef int ext_flag
                    check_type_or_throw_except(
                        _ext_t, 3, float, "External force vector has to be 3 floats.")
                    for i in range(3):
                        ext_t[i] = _ext_t[i]
                    if (ext_t[0] == 0 and ext_t[1] == 0 and ext_t[2] == 0):
                        ext_flag = 0
                    else:
                        ext_flag = PARTICLE_EXT_TORQUE
                    if set_particle_ext_torque(self.id, ext_flag, ext_t) == 1:
                        raise Exception("Set particle position first.")

                def __get__(self):
                    self.update_particle_data()
                    cdef double * ext_t = NULL
                    cdef int * ext_flag = NULL
                    pointer_to_ext_torque(
                        self.particle_data.get(), ext_flag, ext_t)
                    if (ext_flag[0] & PARTICLE_EXT_TORQUE):
                        return np.array([ext_t[0], ext_t[1], ext_t[2]])
                    else:
                        return np.array([0.0, 0.0, 0.0])

    IF LANGEVIN_PER_PARTICLE:
        IF PARTICLE_ANISOTROPY:
            property gamma:
                """
                The rotational frictional coefficient used in the the Langevin thermostat.

                gamma : list of :obj:`float`

                .. note::
                   This needs the feature LANGEVIN_PER_PARTICLE and PARTICLE_ANISOTROPY.

                See Also
                ----------
                :meth:`espressomd.thermostat.Thermostat.set_langevin` : Setting the parameters of the Langevin thermostat

                """

                def __set__(self, _gamma):
                    cdef Vector3d gamma
                    check_type_or_throw_except(
                        _gamma, 3, float, "Friction has to be 3 floats.")
                    for i in range(3):
                        gamma[i] = _gamma[i]
                    if set_particle_gamma(self.id, gamma) == 1:
                        raise Exception("Set particle position first.")

                def __get__(self):
                    self.update_particle_data()
                    cdef double * gamma = NULL
                    pointer_to_gamma(self.particle_data.get(), gamma)
                    return np.array([gamma[0], gamma[1], gamma[2]])
        ELSE:
            property gamma:
                """
                The translational frictional coefficient used in the the Langevin thermostat.

                gamma : :obj:`float`

                .. note::
                   This needs the feature LANGEVIN_PER_PARTICLE.

                See Also
                ----------
                :meth:`espressomd.thermostat.Thermostat.set_langevin.set_langevin` : Setting the parameters of the Langevin thermostat

                """

                def __set__(self, _gamma):
                    check_type_or_throw_except(
                        _gamma, 1, float, "Gamma has to be a float.")
                    if set_particle_gamma(self.id, _gamma) == 1:
                        raise Exception("Set particle position first.")

                def __get__(self):
                    self.update_particle_data()
                    cdef double * gamma = NULL
                    pointer_to_gamma(self.particle_data.get(), gamma)
                    return gamma[0]
        IF ROTATION:
            IF PARTICLE_ANISOTROPY:
                property gamma_rot:
                    """
                    The particle translational frictional coefficient used in the Langevin thermostat.

                    gamma_rot : list of :obj:`float`

                    .. note::
                       This needs the feature LANGEVIN_PER_PARTICLE, ROTATION and PARTICLE_ANISOTROPY.
                    """

                    def __set__(self, _gamma_rot):
                        cdef Vector3d gamma_rot
                        check_type_or_throw_except(
                            _gamma_rot, 3, float, "Rotational friction has to be 3 floats.")
                        for i in range(3):
                            gamma_rot[i] = _gamma_rot[i]
                        if set_particle_gamma_rot(self.id, gamma_rot) == 1:
                            raise Exception("Set particle position first.")

                    def __get__(self):
                        self.update_particle_data()
                        cdef double * gamma_rot = NULL
                        pointer_to_gamma_rot(
                            self.particle_data.get(), gamma_rot)
                        return np.array([gamma_rot[0], gamma_rot[1], gamma_rot[2]])
            ELSE:
                property gamma_rot:
                    """
                    The particle rotational frictional coefficient used in the Langevin thermostat.

                    gamma : :obj:`float`

                    """

                    def __set__(self, _gamma_rot):
                        check_type_or_throw_except(
                            _gamma_rot, 1, float, "gamma_rot has to be a float.")
                        if set_particle_gamma_rot(self.id, _gamma_rot) == 1:
                            raise Exception("Set particle position first.")

                    def __get__(self):
                        self.update_particle_data()
                        cdef double * gamma_rot = NULL
                        pointer_to_gamma_rot(
                            self.particle_data.get(), gamma_rot)
                        return gamma_rot[0]

        property temp:
            """
            Particle's temperature in the Langevin thermostat.

            temp: :obj:`float`

            .. note::
               This needs the feature LANGEVIN_PER_PARTICLE.

            """

            def __set__(self, _temp):
                check_type_or_throw_except(
                    _temp, 1, float, "temp has to be a float.")
                if set_particle_temperature(self.id, _temp) == 1:
                    raise Exception("Set particle position first.")

            def __get__(self):
                self.update_particle_data()
                cdef double * temp = NULL
                pointer_to_temperature(self.particle_data.get(), temp)
                return temp[0]

    IF ROTATION:
        property rotation:
            """
            Switches the particle's rotational degrees of freedom in the Cartesian axes in the body-fixed frame
            The content of the torque and omega variables are meaningless, for the co-ordinates for which
            rotation is disabled.

            The default is not to integrate any rotational degrees of freedom.
            
            rotation : (int,int,int)

            .. note::
               This needs the feature ROTATION.

            """

            def __set__(self, _rot):
                cdef int rot
                check_type_or_throw_except(_rot,3,int,"The rotation flag is given as a tuple of 3 integes.")
                    
                rot=0
                if _rot[0]: rot+=ROT_X
                if _rot[1]: rot+=ROT_Y
                if _rot[2]: rot+=ROT_Z
                if set_particle_rotation(self.id, rot) == 1:
                    raise Exception("Set particle position first.")

            def __get__(self):
                self.update_particle_data()
                cdef short int * _rot = NULL
                pointer_to_rotation( self.particle_data.get(), _rot)
                rot=_rot[0]
                res=np.zeros(3)
                if rot&ROT_X: res[0]=1
                if rot&ROT_Y: res[1]=1
                if rot&ROT_Z: res[2]=1
                return res

    IF EXCLUSIONS:
        property exclusions:
            """
            The exclusion list of particles where nonbonded interactions are ignored.

            .. note::
               This needs the feature EXCLUSIONS.

            """

            def __set__(self, _partners):
                # Delete all
                for e in self.exclusions:
                    self.delete_exclusion(e)

                # Set new exlusion list
                self.add_exclusion(_partners)

            def __get__(self):
                self.update_particle_data()
                cdef int_list exclusions = self.particle_data.get()[0].exclusions()

                py_partners = []
                for i in range(exclusions.n):
                    py_partners.append(exclusions.e[i])
                return py_partners

        def add_exclusion(self, _partners):
            """
            Excluding interaction with given partners.

            Parameters
            -----------
            _partners : list of partners

            """

            if isinstance(_partners, int):
                _partners = [_partners]

            for partner in _partners:

                check_type_or_throw_except(
                    partner, 1, int, "PID of partner has to be an int.")
                if self.id == partner:
                    raise Exception(
                        "Cannot exclude of a particle with itself!\n->particle id %i, partner %i." % (self.id, partner))
                if change_exclusion(self.id, partner, 0) == 1:
                    raise Exception("Set particle position first.")

        def delete_exclusion(self, *_partners):
            for partner in _partners:
                check_type_or_throw_except(
                    partner, 1, int, "PID of partner has to be an int.")
                if change_exclusion(self.id, partner, 1) == 1:
                    raise Exception("Set particle position first.")

    IF ENGINE:
        property swimming:
            """
            Set swimming parameters. 
            
            This property takes a dictionary with a different number of
            entries depending whether there is an implicit fluid (i.e. with the
            Langevin thermostat) of an explicit fluid (with LB).

            Swimming enables the particle to be self-propelled in the direction determined by its
            quaternion. For setting the quaternion of the particle see . The
            self-propulsion speed will relax to a constant velocity, that is specified by
            `v_swim` . Alternatively it is possible to achieve a constant velocity by
            imposing a constant force term `f_swim` that is balanced by friction of a
            (Langevin) thermostat. The way the velocity of the particle decays to the
            constant terminal velocity in either of these methods is completely
            determined by the friction coefficient. You may only set one of the
            possibilities `v_swim` *or* `f_swim` as you cannot relax to constant force
            *and* constant velocity at the same time. The setting both `v_swim` and
            `f_swim` to 0.0 thus disables swimming. This option applies to all
            non-lattice-Boltzmann thermostats. Note that there is no real difference
            between `v_swim` and `f_swim` since the latter may aways be chosen such that
            the same terminal velocity is achieved for a given friction coefficient.


            Parameters
            ----------
            'f_swim' : :obj:`float`
                       Achieve a constant velocity by imposing a constant
                       force term 'f_swim' that is balanced by friction of a
                       (Langevin) thermostat.  This exludes the option
                       'v_swim'.
            'v_swim' : :obj:`float`
                       Achieve a constant velocity by imposing a constant
                       terminal velocity 'v_swim'.  This exludes the option
                       'f_swim'.
            'mode' : string, 'pusher' or 'puller' (initially 'N/A')
                     The LB flow field can be generated by a pushing or a
                     pulling mechanism, leading to change in the sign of the
                     dipolar flow field with respect to the direction of
                     motion.
            'dipole_length' : :obj:`float`
                              This determines the distance of the source of
                              propulsion from the particle's center.
            'rotational_friction' : :obj:`float`
                                    This key can be used to set the friction that causes
                                    the orientation of the particle to change in shear
                                    flow. The torque on the particle is determined by
                                    taking the cross product of the difference between the
                                    fluid velocity at the center of the particle and at
                                    the source point and the vector connecting the center
                                    and source.

            Notes
            -----
            This needs the feature ENGINE.  The keys 'mode',
            'dipole_length', and 'rotational_friction' are only
            available if ENGINE is used with LB or LB_GPU.

            Examples
            --------
            >>> import espressomd
            >>> 
            >>> system = espressomd.System()
            >>> 
            >>> # Usage with Langevin
            >>> system.part.add(id=0, pos=[1,0,0],swimming={'f_swim':0.03})
            >>> 
            >>> # Usage with LB
            >>> system.part.add(id=1, pos=[2,0,0],swimming={
            >>>    'f_swim':0.01, 'mode':'pusher', 'dipole_length':2.0, 'rotational_friction':20})

            """

            def __set__(self, _params):
                cdef particle_parameters_swimming swim
                swim.swimming = True
                swim.v_swim = 0.0
                swim.f_swim = 0.0
                IF LB or LB_GPU:
                    swim.push_pull = 0
                    swim.dipole_length = 0.0
                    swim.rotational_friction = 0.0

                if type(_params) == type(True):
                    if _params == True:
                        raise Exception(
                            "To enable swimming supply a dictionary of parameters.")
                else:
                    if 'f_swim' in _params and 'v_swim' in _params:
                        if _params["f_swim"] == 0 or _params["v_swim"] == 0:
                            pass
                        else:
                            raise Exception(
                                "You can't set v_swim and f_swim at the same time.")
                    if 'f_swim' in _params:
                        check_type_or_throw_except(
                            _params['f_swim'], 1, float, "f_swim has to be a float.")
                        swim.f_swim = _params['f_swim']
                    if 'v_swim' in _params:
                        check_type_or_throw_except(
                            _params['v_swim'], 1, float, "v_swim has to be a float.")
                        swim.v_swim = _params['v_swim']

                    IF LB or LB_GPU:
                        if 'mode' in _params:
                            if _params['mode'] == "pusher":
                                swim.push_pull = -1
                            elif _params['mode'] == "puller":
                                swim.push_pull = 1
                            elif _params['mode'] == "N/A":
                                swim.push_pull = 0
                            else:
                                raise Exception(
                                    "'mode' has to be either 'pusher' or 'puller'.")

                        if 'dipole_length' in _params:
                            check_type_or_throw_except(
                                _params['dipole_length'], 1, float, "dipole_length has to be a float.")
                            swim.dipole_length = _params['dipole_length']

                        if 'rotational_friction' in _params:
                            check_type_or_throw_except(
                                _params['rotational_friction'], 1, float, "rotational_friction has to be a float.")
                            swim.rotational_friction = _params[
                                'rotational_friction']

                if set_particle_swimming(self.id, swim) == 1:
                    raise Exception("Set particle position first.")

            def __get__(self):
                self.update_particle_data()
                swim = {}
                mode = "N/A"
                cdef particle_parameters_swimming * _swim = NULL
                pointer_to_swimming(self.particle_data.get(), _swim)
                IF LB or LB_GPU:
                    if _swim.push_pull == -1:
                        mode = 'pusher'
                    elif _swim.push_pull == 1:
                        mode = 'puller'
                    swim = {
                        'v_swim': _swim.v_swim,
                        'f_swim': _swim.f_swim,
                        'mode': mode,
                        'dipole_length': _swim.dipole_length,
                        'rotational_friction': _swim.rotational_friction
                    }
                ELSE:
                    swim = {
                        'v_swim': _swim.v_swim,
                        'f_swim': _swim.f_swim,
                    }
                return swim

    def remove(self):
        """
        Delete the particle.

        See Also
        --------
        add
        clear

        """

        if remove_particle(self.id):
            raise Exception("Could not delete particle.")
        del self

    # Bond related methods
    # Does not work properly with 3 or more partner bonds!

    def add_verified_bond(self, bond):
        """
        Add a bond, the validity of which has already been verified.

        See Also
        --------
        add_bond : Delete an unverified bond held by the `Particle`.
        bonds : `Particle` property containing a list of all current bonds help by `Particle`.

        """

        # If someone adds bond types with more than four partners, this has to be changed
        cdef int bond_info[5]
        bond_info[0] = bond[0]._bond_id
        for i in range(1, len(bond)):
            bond_info[i] = bond[i]
        if change_particle_bond(self.id, bond_info, 0):
            handle_errors("Adding the bond failed.")

    def delete_verified_bond(self, bond):
        """
        Delete a single bond from the particle. The validity of which has already been verified.

        Parameters
        ----------
        bond : tuple where the first element is either a bond ID of a bond
               type, and the last element is the ID of the parter particle to be
               bonded to.

        See Also
        --------
        delete_bond : Delete an unverified bond held by the `Particle`.
        bonds : `Particle` property containing a list of all current bonds help by `Particle`.

        """

        cdef int bond_info[5]
        bond_info[0] = bond[0]._bond_id
        for i in range(1, len(bond)):
            bond_info[i] = bond[i]
        if change_particle_bond(self.id, bond_info, 1):
            handle_errors("Deleting the bond failed.")

    def check_bond_or_throw_exception(self, bond):
        """
        Checks the validity of the given bond:

            - If the bondtype is given as an object or a numerical id
            - If all partners are of type int
            - If the number of partners satisfies the bond
            - If the bond type used exists (is lower than n_bonded_ia)
            - If the number of bond partners fits the bond type

        Throws an exception if any of these are not met.

        """

        # Has it []-access
        if not hasattr(bond, "__getitem__"):
            raise ValueError(
                "Bond needs to be a tuple or list containing bond type and partners.")

        # Bond type or numerical bond id
        if not isinstance(bond[0], BondedInteraction):
            if isinstance(bond[0], int):
                bond[0] = BondedInteractions()[bond[0]]
            else:
                raise Exception(
                    "1st element of Bond has to be of type BondedInteraction or int.")

        # Check whether the bond has been added to the list of active bonded
        # interactions
        if bond[0]._bond_id == -1:
            raise Exception(
                "The bonded interaction has not yet been added to the list of active bonds in Espresso.")

        # Validity of the numeric id
        if bond[0]._bond_id >= n_bonded_ia:
            raise ValueError("The bond type", bond._bond_id, "does not exist.")

        # Number of partners
        if bonded_ia_params[bond[0]._bond_id].num != len(bond) - 1:
            raise ValueError("Bond of type", bond._bond_id, "needs", bonded_ia_params[
                             bond[0]._bond_id], "partners.")

        # Type check on partners
        for i in range(1, len(bond)):
            if not isinstance(bond[i], int):
                if not isinstance(bond[i], ParticleHandle):
                    raise ValueError(
                        "Bond partners have to be of type integer or ParticleHandle.")
                else:
                    # Put the particle id instead of the particle handle
                    bond[i] = bond[i].id

    def add_bond(self, _bond):
        """
        Add a single bond to the particle.

        Parameters
        ----------
        _bond : tuple where the first element is either a bond ID of a bond
            type, and the last element is the ID of the parter particle to be
            bonded to.


        See Also
        --------
        bonds : `Particle` property containing a list of all current bonds help by `Particle`.

        Examples
        --------
        >>> import espressomd
        >>> from espressomd.interactions import *
        >>>
        >>> system = espressomd.System()
        >>>
        >>> # define a harmonic potential and add it to the system
        >>> harm_bond = HarmonicBond(r_0=1, k=5)
        >>> system.bonded_inter.add(harm_bond)
        >>>
        >>> # add two particles
        >>> system.part.add(id=0, pos=(1, 0, 0))
        >>> system.part.add(id=1, pos=(2, 0, 0))
        >>>
        >>> # bond them via the bond type
        >>> system.part[0].add_bond((harm_bond,1))
        >>> # or via the bond index (zero in this case since it is the first one added)
        >>> system.part[0].add_bond((0,1))

        """

        bond = list(_bond)  # As we will modify it
        self.check_bond_or_throw_exception(bond)
        self.add_verified_bond(bond)

    def delete_bond(self, _bond):
        """
        Delete a single bond from the particle.

        Parameters
        ----------
        _bond : bond to be deleted 

        See Also
        --------
        bonds :  Particle property, a list of all current bonds.


        Examples
        --------

        >>> import espressomd
        >>> from espressomd.interactions import *
        >>>
        >>> system = espressomd.System()

        define a harmonic potential and add it to the system

        >>> harm_bond = HarmonicBond(r_0=1, k=5)
        >>> system.bonded_inter.add(harm_bond)

        add two bonded particles to particle 0

        >>> system.part.add(id=0, pos=(1, 0, 0))
        >>> system.part.add(id=1, pos=(2, 0, 0))
        >>> system.part.add(id=2, pos=(1, 1, 0))
        >>> system.part[0].add_bond((harm_bond,1))
        >>> system.part[0].add_bond((harm_bond,2))
        >>>
        >>> bonds = system.part[0].bonds
        >>> print(bonds)
        ((HarmonicBond(0): {'r_0': 1.0, 'k': 5.0, 'r_cut': 0.0}, 1), (HarmonicBond(0): {'r_0': 1.0, 'k': 5.0, 'r_cut': 0.0}, 2))

        delete the bond betwen particle 0 and particle 1

        >>> system.part[0].delete_bond(bonds[0])
        >>> print(system.part[0].bonds)
        ((HarmonicBond(0): {'r_0': 1.0, 'k': 5.0, 'r_cut': 0.0}, 2),)

        """

        bond = list(_bond)  # as we modify it
        self.check_bond_or_throw_exception(bond)
        self.delete_verified_bond(bond)

    def delete_all_bonds(self):
        """
        Delete all bonds from the particle.

        See Also
        ----------
        delete_bond : Delete an unverified bond held by the Particle.
        bonds : Particle property containing a list of all current bonds help by Particle.

        """

        if change_particle_bond(self.id, NULL, 1):
            handle_errors("Deleting all bonds failed.")

    def update(self, P):
        if "id" in P:
            raise Exception("Cannot change particle id.")

        for k in P.keys():
            setattr(self, k, P[k])

    IF ROTATION:
        def convert_vector_body_to_space(self,vec):
            """Converts the given vector from the particle's body frame to the space frame"""
            cdef Vector3d res
            cdef Vector3d _v
            _v[0]=vec[0]
            _v[1]=vec[1]
            _v[2]=vec[2]
            self.update_particle_data()
            res= convert_vector_body_to_space(self.particle_data.get()[0],_v)
            return np.array((res[0],res[1],res[2]))


cdef class _ParticleSliceImpl(object):
    """Handles slice inputs.

    This base class should not be used directly. Use
    :class:`espressomd.ParticleSlice` instead, which contains all the particle
    properties.

    """

    def __cinit__(self, slice_):
        id_list = np.arange(max_seen_particle + 1)
        self.id_selection = id_list[slice_]
        mask = np.empty(len(self.id_selection), dtype=np.bool)
        mask == True
        cdef int i
        for i in range(len(self.id_selection) - 1, -1, -1):
            mask[i] = particle_exists(i)
        self.id_selection = self.id_selection[mask]

    def __iter__(self):
        cdef int i
        for i in self.id_selection:
            yield ParticleHandle(i)

    cdef int update_particle_data(self, id) except -1:
        self.particle_data = get_particle_data(id)
        if not self.particle_data:
            raise Exception("Error updating particle data.")
        else:
            return 0

    property pos_folded:
        """
        Particle position (folded into central image).

        """

        def __get__(self):
            pos_array = np.zeros((len(self.id_selection), 3))
            for i in range(len(self.id_selection)):
                pos_array[i, :] = ParticleHandle(
                    self.id_selection[i]).pos_folded
            return pos_array

    IF EXCLUSIONS:
        def add_exclusion(self, _partners):
            self.exclude = _partners

        def delete_exclusion(self, _partners):
            if not isinstance(_partners, list):
                raise Exception("List object expected.")
            if isinstance(_partners[0], list):
                for i in range(len(self.id_selection)):
                    ParticleHandle(self.id_selection[
                                   i]).delete_exclusion(_partners[i])
            if isinstance(_partners[0], int):
                for i in range(len(self.id_selection)):
                    ParticleHandle(self.id_selection[
                                   i]).delete_exclusion(_partners)
            else:
                raise TypeError("Unexpected exclusion partner type.")

        def delete_exclusions(self):
            for _id in self.id_selection:
                ParticleHandle(_id).delete_exclusions()

    def __str__(self):
        res = ""
        pl = ParticleList()
        for i in self.id_selection:
            if pl.exists(i):
                res += str(pl[i]) + ", "
        # Remove final comma
        return "ParticleSlice([" + res[:-2] + "])"

    def update(self, P):
        if "id" in P:
            raise Exception("Cannot change particle id.")

        for k in P.keys():
            setattr(self, k, P[k])

    # Bond related methods
    def add_bond(self, _bond):
        """
        Add a single bond to the particles.

        """

        bond = list(_bond)  # As we will modify it
        for i in range(len(self.id_selection)):
            partners = []
            for j in range(1, len(bond)):
                partners.append(bond[j][i])
            ParticleHandle(self.id_selection[i]).add_bond((bond[0], *partners))

    def delete_bond(self, _bond):
        """
        Delete a single bond from the particles.

        """

        bond = list(_bond)  # as we modify it
        for i in range(len(self.id_selection)):
            partners = []
            for j in range(1, len(bond)):
                partners.append(bond[j][i])
            ParticleHandle(self.id_selection[i]).delete_bond((bond[0], *partners))

    def delete_all_bonds(self):
        for i in range(len(self.id_selection)):
            ParticleHandle(self.id_selection[i]).delete_all_bonds()

    def remove(self):
        """
        Delete the particles.

        See Also
        --------
        add

        """

        for id in self.id_selection:
            ParticleHandle(id).remove()


class ParticleSlice(_ParticleSliceImpl):
    """
    Handles slice inputs e.g. part[0:2]. Sets values for selected slices or
    returns values as a single list.

    """

    pass


cdef class ParticleList(object):
    """
    Provides access to the particles via [i], where i is the particle id.
    Returns a ParticleHandle object.

    """

    # Retrieve a particle

    def __getitem__(self, key):
        if isinstance(key, slice):
            return ParticleSlice(key)

        try:
            if isinstance(key, range):
                return ParticleSlice(key)
        except:
            pass

        if isinstance(key, tuple) or isinstance(key, list) or isinstance(key, np.ndarray):
            return ParticleSlice(np.array(key))

        return ParticleHandle(key)

    # __getstate__ and __setstate__ define the pickle interaction
    def __getstate__(self):
        """Attributes to pickle.
        Content of particle_attributes, minus a few exceptions dip, director:
        Setting only the director will overwrite the orientation of the
        particle around the axis parallel to dipole moment/director.
        Quaternions contain the full info id: The particle id is used as the
        storage key when pickling all particles via ParticleList, and the
        interface (rightly) does not support changing of the id after the
        particle was created.

        """

        pickle_attr = copy(particle_attributes)
        for i in ["director", "dip", "id"]:
            if i in pickle_attr:
                pickle_attr.remove(i)
        IF MASS == 0:
            pickle_attr.remove("mass")
        odict = {}
        key_list = [p.id for p in self]
        for particle_number in key_list:
            pdict = {}

            for property_ in pickle_attr:
                pdict[property_] = ParticleHandle(
                    particle_number).__getattribute__(property_)
            odict[particle_number] = pdict
        return odict

    def __setstate__(self, params):
        for particle_number in params.keys():
            params[particle_number]["id"] = particle_number
            self._place_new_particle(params[particle_number])

    def __len__(self):
        return n_part

    def add(self, *args, **kwargs):
        """
        Adds one or several particles to the system

        Parameters
        ----------
        add() takes either a dictionary or a bunch of keyword args.

        Returns
        -------
        Returns an instance of :class:`espressomd.particle_data.ParticleHandle` for each added particle.

        See Also
        --------
        remove

        Examples
        --------

        >>> import espressomd
        >>> from espressomd.interactions import *
        >>>
        >>> system = espressomd.System()
        >>>
        >>> # add two particles
        >>> system.part.add(id=0, pos=(1, 0, 0))
        >>> system.part.add(id=1, pos=(2, 0, 0))
        >>>

        Pos is mandatory, id can be omitted, in which case it is assigned automatically.
        Several particles can be added by passing one value per particle to each property::
            
            system.part.add(pos=((1,2,3),(4,5,6)),q=(1,-1))
        
        """

        # Did we get a dictionary
        if len(args) == 1:
            if hasattr(args[0], "__getitem__"):
                P = args[0]
        else:
            if len(args) == 0 and len(kwargs.keys()) != 0:
                P = kwargs
            else:
                raise ValueError(
                    "add() takes either a dictionary or a bunch of keyword args.")

        # Check for presence of pos attribute
        if not "pos" in P:
            raise ValueError(
                "pos attribute must be specified for new particle")

        if len(np.array(P["pos"]).shape) == 2:
            return self._place_new_particles(P)
        else:
            return self._place_new_particle(P)
 
    def _place_new_particle(self, P):
        # Handling of particle id
        if not "id" in P:
            # Generate particle id
            P["id"] = max_seen_particle + 1
        else:
            if particle_exists(P["id"]):
                raise Exception("Particle %d already exists." % P["id"])


        # The ParticleList[]-getter ist not valid yet, as the particle
        # doesn't yet exist. Hence, the setting of position has to be
        # done here. the code is from the pos:property of ParticleHandle
        cdef double mypos[3]
        check_type_or_throw_except(
            P["pos"], 3, float, "Postion must be 3 floats.")
        for i in range(3):
            mypos[i] = P["pos"][i]
        if place_particle(P["id"], mypos) == -1:
            raise Exception("particle could not be set.")
        # Pos is taken care of
        del P["pos"]
        id = P["id"]
        del P["id"]

        if P != {}:
            self[id].update(P)

        return self[id]

    def _place_new_particles(self, P):
        if not "id" in P:
            # Generate particle ids
            ids = np.arange(np.array(P["pos"]).shape[
                            0]) + max_seen_particle + 1
        else:
            ids = P["id"]
            del P["id"]

        # Place particles
        cdef double mypos[3]
        for j in range(len(P["pos"])):
            for i in range(3):
                mypos[i] = P["pos"][j][i]
            if place_particle(ids[j], mypos) == -1:
                raise Exception("Particle could not be set.")

        del P["pos"]

        if P != {}:
            self[ids].update(P)

        return self[ids]

    # Iteration over all existing particles
    def __iter__(self):
        for i in range(max_seen_particle + 1):
            if particle_exists(i):
                yield self[i]

    def exists(self, idx):
        if isinstance(idx, int) or issubclass(type(idx), np.integer):
            return particle_exists(idx)
        if isinstance(idx, slice) or isinstance(idx, tuple) or isinstance(idx, list) or isinstance(idx, np.ndarray):
            tf_array = np.zeros(len(idx), dtype=np.bool)
            for i in range(len(idx)):
                tf_array[i] = particle_exists(idx[i])
            return tf_array

    def clear(self):
        """
        Removes all particles.

        See Also
        --------
        add
        remove
        
        """

        remove_all_particles()

    def __str__(self):
        res = ""
        for i in range(max_seen_particle + 1):
            if self.exists(i):
                res += str(self[i]) + ", "
        # Remove final comma
        return "ParticleList([" + res[:-2] + "])"

    def writevtk(self, fname, types='all'):
        """
        Write the positions and velocities of particles with specified
        types to a VTK file.
 
        Parameters
        ----------
 
        fname: :obj:`str`
               Filename of the target output file
        types: list of :obj:`int` or the string 'all', optional (default: 'all')
               A list of particle types which should be output to 'fname'
   
        Examples
        --------
 
        >>> import espressomd
        >>> 
        >>> system = espressomd.System()
        >>> 
        >>> # add several particles
        >>> system.part.add(pos=.5*system.box_l,v=[1,0,0],type=0)
        >>> system.part.add(pos=.4*system.box_l,v=[0,2,0],type=1)
        >>> system.part.add(pos=.7*system.box_l,v=[2,0,1],type=1)
        >>> system.part.add(pos=.1*system.box_l,v=[0,0,1],type=2)
        >>> 
        >>> # write to VTK
        >>> system.part.writevtk("part_type_0_1.vtk", types=[0,1])
        >>> system.part.writevtk("part_type_2.vtk", types=[2])
        >>> system.part.writevtk("part_all.vtk")
 
        .. todo:: `move to ./io/writer/`

        """
        global box_l
        if not hasattr(types, '__iter__'):
            types = [types]

        n = 0
        for p in self:
            for t in types:
                if (p.type == t or t == "all"):
                    n += 1

        with open(fname, "w") as vtk:
            vtk.write("# vtk DataFile Version 2.0\n")
            vtk.write("particles\n")
            vtk.write("ASCII\n")
            vtk.write("DATASET UNSTRUCTURED_GRID\n")
            vtk.write("POINTS {} floats\n".format(n))
            for p in self:
                for t in types:
                    if (p.type == t or t == "all"):
                        vtk.write("{} {} {}\n".format(*(p.pos % box_l)))

            vtk.write("POINT_DATA {}\n".format(n))
            vtk.write("SCALARS velocity float 3\n")
            vtk.write("LOOKUP_TABLE default\n")
            for p in self:
                for t in types:
                    if (p.type == t or t == "all"):
                        vtk.write("{} {} {}\n".format(*p.v))

    property highest_particle_id:
        """
        Largest particle id.

        """

        def __get__(self):
            return max_seen_particle

    property n_part_types:
        """
        Number of particle types.

        """

        def __get__(self):
            return n_particle_types

    property n_rigidbonds:
        """
        Number of rigid bonds.

        """

        def __get__(self):
            return n_rigidbonds

    # property max_part:
    #     def __get__(self):
    #         return max_seen_particle

    # # property n_part:
    #     def __get__(self):
    #         return n_part

    def pairs(self):
        """
        Generator returns all pairs of particles.

        """

        for i in range(max_seen_particle + 1):
            for j in range(i + 1, max_seen_particle + 1, 1):
                if not (self.exists(i) and self.exists(j)):
                    continue
                yield (self[i], self[j])


def _add_particle_slice_properties():
    """
    Automatically add all of ParticleHandle's properties to ParticleSlice.

    """
    def seta(particle_slice, values, attribute):
        """
        Setter function that sets attribute on every member of particle_slice.
        If values contains only one element, all members are set to it. If it
        contains as many elements as there are members, each of them gets set
        to the corresponding one.
        
        """
        target = getattr(ParticleHandle(
            particle_slice.id_selection[0]), attribute)
        target_shape = np.shape(target)
        N = len(particle_slice.id_selection)

        if not target_shape:  # scalar quantity
            if not np.shape(values):  # one value provided
                for i in range(N):
                    setattr(ParticleHandle(
                        particle_slice.id_selection[i]), attribute, values)
            elif np.shape(values)[0] == N:  # one value for each particle provided
                for i in range(N):
                    setattr(ParticleHandle(
                        particle_slice.id_selection[i]), attribute, values[i])
            else:
                raise Exception("Shape of value (%s) does not broadcast to shape of attribute (%s)." % (
                    np.shape(values), target_shape))
            return

        if target_shape == np.shape(values):  # one value provided
            for i in range(N):
                setattr(ParticleHandle(
                    particle_slice.id_selection[i]), attribute, values)
        # one value for each particle provided
        elif target_shape == tuple(np.shape(values)[1:]) and np.shape(values)[0] == N:
            for i in range(N):
                setattr(ParticleHandle(
                    particle_slice.id_selection[i]), attribute, values[i])
        else:
            raise Exception("Shape of value (%s) does not broadcast to shape of attribute (%s)." % (
                np.shape(values), target_shape))

    def geta(particle_slice, attribute):
        """
        Getter function that copies attribute from every member of
        particle_slice into an array.
        
        """
        
        N = len(particle_slice.id_selection)
        if N == 0:
            return np.empty(0, dtype=type(None))

        # get first slice member to determine its type
        target = getattr(ParticleHandle(
            particle_slice.id_selection[0]), attribute)
        if type(target) is np.ndarray:  # vectorial quantity
            target_type = target.dtype
        else:  # scalar quantity
            target_type = type(target)

        values = np.empty((N,) + np.shape(target), dtype=target_type)
        for i in range(N):
            values[i] = getattr(ParticleHandle(
                particle_slice.id_selection[i]), attribute)
        return values

    for attribute_name in particle_attributes:
        if attribute_name in dir(ParticleSlice):
            continue

        # synthesize a new property
        new_property = property(functools.partial(geta, attribute=attribute_name), functools.partial(
            seta, attribute=attribute_name), doc=getattr(ParticleHandle, attribute_name).__doc__)
        # attach the property to ParticleSlice
        setattr(ParticleSlice, attribute_name, new_property)


_add_particle_slice_properties()
